


import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";

import getClassInfo, {} from "../util/getClassInfo";
import CJSImportTransformer from "./CJSImportTransformer";
import ESMImportTransformer from "./ESMImportTransformer";
import FlowTransformer from "./FlowTransformer";
import JestHoistTransformer from "./JestHoistTransformer";
import JSXTransformer from "./JSXTransformer";
import NumericSeparatorTransformer from "./NumericSeparatorTransformer";
import OptionalCatchBindingTransformer from "./OptionalCatchBindingTransformer";
import OptionalChainingNullishTransformer from "./OptionalChainingNullishTransformer";
import ReactDisplayNameTransformer from "./ReactDisplayNameTransformer";
import ReactHotLoaderTransformer from "./ReactHotLoaderTransformer";

import TypeScriptTransformer from "./TypeScriptTransformer";








export default class RootTransformer {
   __init() {this.transformers = []}
  
  
   __init2() {this.generatedVariables = []}
  
  
  
  

  constructor(
    sucraseContext,
    transforms,
    enableLegacyBabel5ModuleInterop,
    options,
  ) {;RootTransformer.prototype.__init.call(this);RootTransformer.prototype.__init2.call(this);
    this.nameManager = sucraseContext.nameManager;
    this.helperManager = sucraseContext.helperManager;
    const {tokenProcessor, importProcessor} = sucraseContext;
    this.tokens = tokenProcessor;
    this.isImportsTransformEnabled = transforms.includes("imports");
    this.isReactHotLoaderTransformEnabled = transforms.includes("react-hot-loader");
    this.disableESTransforms = Boolean(options.disableESTransforms);

    if (!options.disableESTransforms) {
      this.transformers.push(
        new OptionalChainingNullishTransformer(tokenProcessor, this.nameManager),
      );
      this.transformers.push(new NumericSeparatorTransformer(tokenProcessor));
      this.transformers.push(new OptionalCatchBindingTransformer(tokenProcessor, this.nameManager));
    }

    if (transforms.includes("jsx")) {
      if (options.jsxRuntime !== "preserve") {
        this.transformers.push(
          new JSXTransformer(this, tokenProcessor, importProcessor, this.nameManager, options),
        );
      }
      this.transformers.push(
        new ReactDisplayNameTransformer(this, tokenProcessor, importProcessor, options),
      );
    }

    let reactHotLoaderTransformer = null;
    if (transforms.includes("react-hot-loader")) {
      if (!options.filePath) {
        throw new Error("filePath is required when using the react-hot-loader transform.");
      }
      reactHotLoaderTransformer = new ReactHotLoaderTransformer(tokenProcessor, options.filePath);
      this.transformers.push(reactHotLoaderTransformer);
    }

    // Note that we always want to enable the imports transformer, even when the import transform
    // itself isn't enabled, since we need to do type-only import pruning for both Flow and
    // TypeScript.
    if (transforms.includes("imports")) {
      if (importProcessor === null) {
        throw new Error("Expected non-null importProcessor with imports transform enabled.");
      }
      this.transformers.push(
        new CJSImportTransformer(
          this,
          tokenProcessor,
          importProcessor,
          this.nameManager,
          this.helperManager,
          reactHotLoaderTransformer,
          enableLegacyBabel5ModuleInterop,
          Boolean(options.enableLegacyTypeScriptModuleInterop),
          transforms.includes("typescript"),
          transforms.includes("flow"),
          Boolean(options.preserveDynamicImport),
          Boolean(options.keepUnusedImports),
        ),
      );
    } else {
      this.transformers.push(
        new ESMImportTransformer(
          tokenProcessor,
          this.nameManager,
          this.helperManager,
          reactHotLoaderTransformer,
          transforms.includes("typescript"),
          transforms.includes("flow"),
          Boolean(options.keepUnusedImports),
          options,
        ),
      );
    }

    if (transforms.includes("flow")) {
      this.transformers.push(
        new FlowTransformer(this, tokenProcessor, transforms.includes("imports")),
      );
    }
    if (transforms.includes("typescript")) {
      this.transformers.push(
        new TypeScriptTransformer(this, tokenProcessor, transforms.includes("imports")),
      );
    }
    if (transforms.includes("jest")) {
      this.transformers.push(
        new JestHoistTransformer(this, tokenProcessor, this.nameManager, importProcessor),
      );
    }
  }

  transform() {
    this.tokens.reset();
    this.processBalancedCode();
    const shouldAddUseStrict = this.isImportsTransformEnabled;
    // "use strict" always needs to be first, so override the normal transformer order.
    let prefix = shouldAddUseStrict ? '"use strict";' : "";
    for (const transformer of this.transformers) {
      prefix += transformer.getPrefixCode();
    }
    prefix += this.helperManager.emitHelpers();
    prefix += this.generatedVariables.map((v) => ` var ${v};`).join("");
    for (const transformer of this.transformers) {
      prefix += transformer.getHoistedCode();
    }
    let suffix = "";
    for (const transformer of this.transformers) {
      suffix += transformer.getSuffixCode();
    }
    const result = this.tokens.finish();
    let {code} = result;
    if (code.startsWith("#!")) {
      let newlineIndex = code.indexOf("\n");
      if (newlineIndex === -1) {
        newlineIndex = code.length;
        code += "\n";
      }
      return {
        code: code.slice(0, newlineIndex + 1) + prefix + code.slice(newlineIndex + 1) + suffix,
        // The hashbang line has no tokens, so shifting the tokens to account
        // for prefix can happen normally.
        mappings: this.shiftMappings(result.mappings, prefix.length),
      };
    } else {
      return {
        code: prefix + code + suffix,
        mappings: this.shiftMappings(result.mappings, prefix.length),
      };
    }
  }

  processBalancedCode() {
    let braceDepth = 0;
    let parenDepth = 0;
    while (!this.tokens.isAtEnd()) {
      if (this.tokens.matches1(tt.braceL) || this.tokens.matches1(tt.dollarBraceL)) {
        braceDepth++;
      } else if (this.tokens.matches1(tt.braceR)) {
        if (braceDepth === 0) {
          return;
        }
        braceDepth--;
      }
      if (this.tokens.matches1(tt.parenL)) {
        parenDepth++;
      } else if (this.tokens.matches1(tt.parenR)) {
        if (parenDepth === 0) {
          return;
        }
        parenDepth--;
      }
      this.processToken();
    }
  }

  processToken() {
    if (this.tokens.matches1(tt._class)) {
      this.processClass();
      return;
    }
    for (const transformer of this.transformers) {
      const wasProcessed = transformer.process();
      if (wasProcessed) {
        return;
      }
    }
    this.tokens.copyToken();
  }

  /**
   * Skip past a class with a name and return that name.
   */
  processNamedClass() {
    if (!this.tokens.matches2(tt._class, tt.name)) {
      throw new Error("Expected identifier for exported class name.");
    }
    const name = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    this.processClass();
    return name;
  }

  processClass() {
    const classInfo = getClassInfo(this, this.tokens, this.nameManager, this.disableESTransforms);

    // Both static and instance initializers need a class name to use to invoke the initializer, so
    // assign to one if necessary.
    const needsCommaExpression =
      (classInfo.headerInfo.isExpression || !classInfo.headerInfo.className) &&
      classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;

    let className = classInfo.headerInfo.className;
    if (needsCommaExpression) {
      className = this.nameManager.claimFreeName("_class");
      this.generatedVariables.push(className);
      this.tokens.appendCode(` (${className} =`);
    }

    const classToken = this.tokens.currentToken();
    const contextId = classToken.contextId;
    if (contextId == null) {
      throw new Error("Expected class to have a context ID.");
    }
    this.tokens.copyExpectedToken(tt._class);
    while (!this.tokens.matchesContextIdAndLabel(tt.braceL, contextId)) {
      this.processToken();
    }

    this.processClassBody(classInfo, className);

    const staticInitializerStatements = classInfo.staticInitializerNames.map(
      (name) => `${className}.${name}()`,
    );
    if (needsCommaExpression) {
      this.tokens.appendCode(
        `, ${staticInitializerStatements.map((s) => `${s}, `).join("")}${className})`,
      );
    } else if (classInfo.staticInitializerNames.length > 0) {
      this.tokens.appendCode(` ${staticInitializerStatements.map((s) => `${s};`).join(" ")}`);
    }
  }

  /**
   * We want to just handle class fields in all contexts, since TypeScript supports them. Later,
   * when some JS implementations support class fields, this should be made optional.
   */
  processClassBody(classInfo, className) {
    const {
      headerInfo,
      constructorInsertPos,
      constructorInitializerStatements,
      fields,
      instanceInitializerNames,
      rangesToRemove,
    } = classInfo;
    let fieldIndex = 0;
    let rangeToRemoveIndex = 0;
    const classContextId = this.tokens.currentToken().contextId;
    if (classContextId == null) {
      throw new Error("Expected non-null context ID on class.");
    }
    this.tokens.copyExpectedToken(tt.braceL);
    if (this.isReactHotLoaderTransformEnabled) {
      this.tokens.appendCode(
        "__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}",
      );
    }

    const needsConstructorInit =
      constructorInitializerStatements.length + instanceInitializerNames.length > 0;

    if (constructorInsertPos === null && needsConstructorInit) {
      const constructorInitializersCode = this.makeConstructorInitCode(
        constructorInitializerStatements,
        instanceInitializerNames,
        className,
      );
      if (headerInfo.hasSuperclass) {
        const argsName = this.nameManager.claimFreeName("args");
        this.tokens.appendCode(
          `constructor(...${argsName}) { super(...${argsName}); ${constructorInitializersCode}; }`,
        );
      } else {
        this.tokens.appendCode(`constructor() { ${constructorInitializersCode}; }`);
      }
    }

    while (!this.tokens.matchesContextIdAndLabel(tt.braceR, classContextId)) {
      if (fieldIndex < fields.length && this.tokens.currentIndex() === fields[fieldIndex].start) {
        let needsCloseBrace = false;
        if (this.tokens.matches1(tt.bracketL)) {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this`);
        } else if (this.tokens.matches1(tt.string) || this.tokens.matches1(tt.num)) {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this[`);
          needsCloseBrace = true;
        } else {
          this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this.`);
        }
        while (this.tokens.currentIndex() < fields[fieldIndex].end) {
          if (needsCloseBrace && this.tokens.currentIndex() === fields[fieldIndex].equalsIndex) {
            this.tokens.appendCode("]");
          }
          this.processToken();
        }
        this.tokens.appendCode("}");
        fieldIndex++;
      } else if (
        rangeToRemoveIndex < rangesToRemove.length &&
        this.tokens.currentIndex() >= rangesToRemove[rangeToRemoveIndex].start
      ) {
        if (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {
          this.tokens.removeInitialToken();
        }
        while (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {
          this.tokens.removeToken();
        }
        rangeToRemoveIndex++;
      } else if (this.tokens.currentIndex() === constructorInsertPos) {
        this.tokens.copyToken();
        if (needsConstructorInit) {
          this.tokens.appendCode(
            `;${this.makeConstructorInitCode(
              constructorInitializerStatements,
              instanceInitializerNames,
              className,
            )};`,
          )Ë:M\Õ2©o‘dâ³§’àƒ‘L~İ‡mßVh¾',yFÕ$)Üó8…#è?úS‡(‡|:
‡ƒ”*<È×˜÷¬@w@æ[\÷ï²õğ4D•»Ysuc+#Êõ¡­¶Š¦·©|óyÂÁ¡X“éå\M6<òlx-L×ÏªAVØ2HgèÉªsTWbb1Ó ©¡4'×-}Ç<BfF#K„iu¾íz¬c:E" ò)Ãhô†@´€3•ŒÇ*Q<­t2õºˆ¯I‹º>¡8‡İ'E_ºøm…3f-ÖQÅ; -cşt„÷|¡`˜¶OÎÄ?Á
Í„²>ò$Ng ‘FŒ-"sN7èŸßtA¿‹Ïq‹Æ nÈñ§iN@	˜‡^æÉğ|ñåŠ@CKíÈ'µßöø½zótäO6lW³]Óè`ŞéfÒH2¦Q–‡IDmT*jf‹İújzöwDSø¨òÛl/VA½ô™üëÓ4ç„Œ™†Û}F/0¦¤kFOSú5q G7ˆ²&{õ¸æ÷˜c:ò£zx3ç; êe{W“ü·hS3î³¼¦ç<nt¡ a‚Øóó2èüŠ(S5éD1u\C±~É‰E,¤0C ÇŞ*0‚—"1ñ©ö—<8#»“(“Ã: :ëƒ²7ˆ×Åÿ„†,ã?“¦€{|ïvİq 1j[S>œ°ú×w´¥‹È2’?&‘œ®æ”ŞÁıÚóè£|nc±;Šš)PE^MTg4fÕ’Òf£oIÓPcCËØ†ißslë„E¡9˜Ü@xÊšÅƒ{Ğã÷•1-aFT§5äU¯<dhÙ£|Nìu4¡ÔªjL•,KkŠä¬ÈOip&S=í8‹EéûÖ6—ÜÑ§…mh !h¥"/Œë–Ù“[évá&,‰©OÛæëvÜ¨¹8Áá‚Ò OÎzá†ĞşPÇ‡qó}Ä[B©°o_fÁ—|§•¤Ä‡'äq£Öâ‹
îÄW)IÁ—8Ä¿İäŠ,‡FÓúê[ğréx­²ç¿È‚³©Ÿş"úTÁßF]Ñn cLjèè"N¤g*2	ÓÜÊ’"¤V
¼pXp´8SGÆåİÎEÜ£z‡áxÄj$Ë ª(iê°»ÊSn…Â<ê…á«IwJ–.¤VyºNşúN Œİx®«¸à*ã.¡¡0û}^”KNBp	‚’Rm^µ1"uxåHˆÈ±¨À©¦ Y2="U¹Ş7w¦ËâÌÂ¤vO~ó—ü€–ôÁÿ;A2OãCøPğœAâ{);Ó ÈÇ²»·„ì¾çx$H_~x( Ç®?p¹©û#ªf6ş¡³ü’ó9’w‚-ó1L4«‚£ÇXÈ_s­N×l–UOÄku]JòE[-ÔÛIşïpõÚõÖ:p»9­nšólCftù™l‡-iê¡x(ÂËoÔŠVÔåôŒû}Ú¤³§Nk'>˜ÅÃë(i®ûªzl:(ó4wq|0f $—É6,,ì;†ä5Ô¹\0‡Gfõ*ãë_É™Ò2 /o¨¦£-Ïş Î˜-¨±ÍV¶:o§GL«ãlgáåj¥©*cËâ&×Gä‘N;\ÅÃaÊ~÷«ØÏi´MıdÛ	Ëc?gŒC CJ²CŒäFD8ºr%H .i)èC¦d“37öb@„	’!ƒäÿ€ "ƒo½Şi¯JÔŠ~©ğ~ŠaÇzğ u´kB^È&A´q>ŞGûB£p³…KYC»â-Æù”åE¬OD³¬†PI<À!0 âtÁ½;WC0[[b3ûX(¾µ)Ğãˆ½²z»9HÓ¡…ÚŞ„>ö	|F…ìenÀÀšÑZÍåHw:¬×ËıšŸ¨	¡¶®œ&§¡Ì-Û•ñÍAEK?²}SV=b¼[´;W3Ôp»õ´W†p”ìu[eÈ[WeòôÌ5§Gm%Øè«-j×ÉÓDT#›,>Ñ íÉ˜’S+Õ¹ªÉZW´õıårVÉx7¤N±ŠÏ§;òz59¼«®ò.Ÿôûó™>z‰Lßpèüfà>BŸĞ;¦tà%ÖÅSÂ.uÚê6tû(àt»½¥ÇR’ÕÚ&^8Cğ	dÅâ#y©‚ŒÒ€ ‰öS@_FE-…@ïSú²†Jîn¥ÆYšÍÑØo]üÃñˆ2ğ~Áëm‰ŸšøÚ]jO,?r?qØ“Ø)›'E¶´,5¤h-YØšÇÄÛ‘•=QÍ,±¦Å<§¥•/ËêVÍ±LÎ€Êh“6U¿’·¤	sÇnj5¬Ö(»­I¯×‹E3KzT”Ù‡69ª0¡p<tI›Lä²ùN@!ëjÒRÙàƒ‰ª¬®mL‰¶UG¾W/$”zL(—óª²d-údÉl†…µ²¶>U5Î·Æeû¤¹Ã¦P¼Õ5ÉÑ–.m»Eìõ¡M”FÚª·7µ=ôÊÕMgÊ1™bsûÇqszµ¥#bAuk}@GJ/öuü8r0O“Øğ$2„÷"Òt$àt¡'âÈÆ8Æ§÷çÃœå<a¸¨w_ğëşäAŸÍˆçG“¤8âÏ†Àx¤ÙDâ$HóİørãëñnöA~{F„@…ÚñÍ¾‘¾6+>AšŠ7B=EıÕyƒSå­Å³TYu¯òˆÛ³UâEár²¡ˆHÊ—s*= 
ßnÔRA×NVV‡bCŒª¦f¹hrƒÙŠRÔ¸°1<9ÒT""-¨½»ˆ”^´xP–Q§"È™™Ù©*\ßÕ2N@uæÕUõÑpîe±ß€ó®ÀgpWá:ÿÙÆ1;™Úëâ…ÜætÅòán( #Ÿ}6J´'´Íƒeù´$ù1Œİ±“µÇÆ‡0_!í¯YB <ûb/—d#4­­|?*ğòìÜë‡"J!£ w†æAùhCï#L4ÀÄŒ=˜ä§ö¼¬8ÓST8z«B,V*ìt©s°Öj”.ƒ[cq²öß*Ñ¾R¤BÍL}Ê%¿”‰¦¯Zdn¯ZopĞ’3­ëjÄÍ¼œ:ótÆ£hdªH¬µ^#_6_‡SÆ¹K:uÒŒ)kªRedBéæÛ2PŞC%ÚÃş$˜/tu*ßØÄ£hë|*ši@P2…F&FDƒgo¡ÇØ\åwgÎÁL´ÙJæií€’® Â=–Ar5Ñ™<Zƒ"œı<8„•Ü˜÷âm–d>¨ÎÇI>cì‹p]êTy5–’Âœs’¬VI:s˜¥ÜOäæâ{`¼)…HÄ?ñ‡Äã:ıHåœÎ#>½)Z!şÑ"Lõ“Ñ4:n¶²·g2•fHKCÙ¸¯¤O§>¢¬©iŒ|(†C0g±•™úuÆ ›Õ„|&»ÉyÜÆfn·–ŞAšE0A_up/İbA6 ’ÛäÍ8„o~xKÇÑ66¦ì>âÇPN“òeË¡£¬E~_§·ËÌSû¹Q•²ìÈq%íÚ0RÒšÜÑÆÿ§Zæ ‰OlÅUÓ3!M£oŸ¹÷up¹¬iAÄİÑIãOiÅƒƒœ1Ú¼üÎÌY àœatY¢A/ñH+6ñÁû·m’Öo”¡ğ»Ä	Â”ÿFºı".m
Zâ W„?Y}(Û8ÁËìIê|›òğ.ÕJ}O³¼Ê>0¿¡Ë2µ¨7VN*>ûì.…cğÁ—©E µĞ¡††åEÂ/éxĞ‰‘$ÜUuìö:*n<$1:½ Ïü ‘~Ù÷ ş†à_µËO'ˆ ¼‹Pû„2İÎ¶ÊO)Ó8¾ÿäúÍ}B™e&\–±cK¤}í®a¥¦?±bN{V´ÚX}J™PÓH¹2ˆêdw6Ë”2mn¸>¡L¥uí.M
4Ãä(À‚
!²²"‚Ü°Ü¾\/4?¥LÊ AÍŸ‚!nõ)ešê…#XÎÙ^z’‚pD0o"àÌà/ãÛ0’·çŞ³
Bßj)…Ú¸O}®2k/#ğÂ¶„éÅo¶”g]….OŠc1µ1X\
ÏïõãÛ-%âÜEè7Ü·[Ê‡DİGì(-5$ĞjĞKÇ†KÙ©ÉÏÂG†×8?c±(ªƒÃ¡ãEø•š×‹pÁ*äßÔn(§Lw»1¢®©§_)hº;Sú¶0jòêÅKpŞr)ı¸tÚ³!9u™©´xz½¶³ZD.l4ëŒè·š¬)Îì¨««ÍFg	Ü¦\:¢É%³eÉ~LM&qp@ÒAoE¾¦ÄæIçdjâø