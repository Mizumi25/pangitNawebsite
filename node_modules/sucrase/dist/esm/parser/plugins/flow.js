/* eslint max-len: 0 */

import {
  eat,
  lookaheadType,
  lookaheadTypeAndKeyword,
  match,
  next,
  popTypeContext,
  pushTypeContext,

} from "../tokenizer/index";
import {ContextualKeyword} from "../tokenizer/keywords";
import {TokenType, TokenType as tt} from "../tokenizer/types";
import {input, state} from "../traverser/base";
import {
  baseParseMaybeAssign,
  baseParseSubscript,
  baseParseSubscripts,
  parseArrow,
  parseArrowExpression,
  parseCallExpressionArguments,
  parseExprAtom,
  parseExpression,
  parseFunctionBody,
  parseIdentifier,
  parseLiteral,

} from "../traverser/expression";
import {
  baseParseExportStar,
  parseExport,
  parseExportFrom,
  parseExportSpecifiers,
  parseFunctionParams,
  parseImport,
  parseStatement,
} from "../traverser/statement";
import {
  canInsertSemicolon,
  eatContextual,
  expect,
  expectContextual,
  isContextual,
  isLookaheadContextual,
  semicolon,
  unexpected,
} from "../traverser/util";

function isMaybeDefaultImport(lookahead) {
  return (
    (lookahead.type === tt.name || !!(lookahead.type & TokenType.IS_KEYWORD)) &&
    lookahead.contextualKeyword !== ContextualKeyword._from
  );
}

function flowParseTypeInitialiser(tok) {
  const oldIsType = pushTypeContext(0);
  expect(tok || tt.colon);
  flowParseType();
  popTypeContext(oldIsType);
}

function flowParsePredicate() {
  expect(tt.modulo);
  expectContextual(ContextualKeyword._checks);
  if (eat(tt.parenL)) {
    parseExpression();
    expect(tt.parenR);
  }
}

function flowParseTypeAndPredicateInitialiser() {
  const oldIsType = pushTypeContext(0);
  expect(tt.colon);
  if (match(tt.modulo)) {
    flowParsePredicate();
  } else {
    flowParseType();
    if (match(tt.modulo)) {
      flowParsePredicate();
    }
  }
  popTypeContext(oldIsType);
}

function flowParseDeclareClass() {
  next();
  flowParseInterfaceish(/* isClass */ true);
}

function flowParseDeclareFunction() {
  next();
  parseIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  expect(tt.parenL);
  flowParseFunctionTypeParams();
  expect(tt.parenR);

  flowParseTypeAndPredicateInitialiser();

  semicolon();
}

function flowParseDeclare() {
  if (match(tt._class)) {
    flowParseDeclareClass();
  } else if (match(tt._function)) {
    flowParseDeclareFunction();
  } else if (match(tt._var)) {
    flowParseDeclareVariable();
  } else if (eatContextual(ContextualKeyword._module)) {
    if (eat(tt.dot)) {
      flowParseDeclareModuleExports();
    } else {
      flowParseDeclareModule();
    }
  } else if (isContextual(ContextualKeyword._type)) {
    flowParseDeclareTypeAlias();
  } else if (isContextual(ContextualKeyword._opaque)) {
    flowParseDeclareOpaqueType();
  } else if (isContextual(ContextualKeyword._interface)) {
    flowParseDeclareInterface();
  } else if (match(tt._export)) {
    flowParseDeclareExportDeclaration();
  } else {
    unexpected();
  }
}

function flowParseDeclareVariable() {
  next();
  flowParseTypeAnnotatableIdentifier();
  semicolon();
}

function flowParseDeclareModule() {
  if (match(tt.string)) {
    parseExprAtom();
  } else {
    parseIdentifier();
  }

  expect(tt.braceL);
  while (!match(tt.braceR) && !state.error) {
    if (match(tt._import)) {
      next();
      parseImport();
    } else {
      unexpected();
    }
  }
  expect(tt.braceR);
}

function flowParseDeclareExportDeclaration() {
  expect(tt._export);

  if (eat(tt._default)) {
    if (match(tt._function) || match(tt._class)) {
      // declare export default class ...
      // declare export default function ...
      flowParseDeclare();
    } else {
      // declare export default [type];
      flowParseType();
      semicolon();
    }
  } else if (
    match(tt._var) || // declare export var ...
    match(tt._function) || // declare export function ...
    match(tt._class) || // declare export class ...
    isContextual(ContextualKeyword._opaque) // declare export opaque ..
  ) {
    flowParseDeclare();
  } else if (
    match(tt.star) || // declare export * from ''
    match(tt.braceL) || // declare export {} ...
    isContextual(ContextualKeyword._interface) || // declare export interface ...
    isContextual(ContextualKeyword._type) || // declare export type ...
    isContextual(ContextualKeyword._opaque) // declare export opaque type ...
  ) {
    parseExport();
  } else {
    unexpected();
  }
}

function flowParseDeclareModuleExports() {
  expectContextual(ContextualKeyword._exports);
  flowParseTypeAnnotation();
  semicolon();
}

function flowParseDeclareTypeAlias() {
  next();
  flowParseTypeAlias();
}

function flowParseDeclareOpaqueType() {
  next();
  flowParseOpaqueType(true);
}

function flowParseDeclareInterface() {
  next();
  flowParseInterfaceish();
}

// Interfaces

function flowParseInterfaceish(isClass = false) {
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  if (eat(tt._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (!isClass && eat(tt.comma));
  }

  if (isContextual(ContextualKeyword._mixins)) {
    next();
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }

  if (isContextual(ContextualKeyword._implements)) {
    next();
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }

  flowParseObjectType(isClass, false, isClass);
}

function flowParseInterfaceExtends() {
  flowParseQualifiedTypeIdentifier(false);
  if (match(tt.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseInterface() {
  flowParseInterfaceish();
}

function flowParseRestrictedIdentifier() {
  parseIdentifier();
}

function flowParseTypeAlias() {
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  flowParseTypeInitialiser(tt.eq);
  semicolon();
}

function flowParseOpaqueType(declare) {
  expectContextual(ContextualKeyword._type);
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  // Parse the supertype
  if (match(tt.colon)) {
    flowParseTypeInitialiser(tt.colon);
  }

  if (!declare) {
    flowParseTypeInitialiser(tt.eq);
  }
  semicolon();
}

function flowParseTypeParameter() {
  flowParseVariance();
  flowParseTypeAnnotatableIdentifier();

  if (eat(tt.eq)) {
    flowParseType();
  }
}

export function flowParseTypeParameterDeclaration() {
  const oldIsType = pushTypeContext(0);
  // istanbul ignore else: this condition is already checked at all call sites
  if (match(tt.lessThan) || match(tt.typeParameterStart)) {
    next();
  } else {
    unexpected();
  }

  do {
    flowParseTypeParameter();
    if (!match(tt.greaterThan)) {
      expect(tt.comma);
    }
  } while (!match(tt.greaterThan) && !state.error);
  expect(tt.greaterThan);
  popTypeContext(oldIsType);
}

function flowParseTypeParameterInstantiation() {
  const oldIsType = pushTypeContext(0);
  expect(tt.lessThan);
  while (!match(tt.greaterThan) && !state.error) {
    flowParseType();
    if (!match(tt.greaterThan)) {
      expect(tt.comma);
    }
  }
  expect(tt.greaterThan);
  popTypeContext(oldIsType);
}

function flowParseInterfaceType() {
  expectContextual(ContextualKeyword._interface);
  if (eat(tt._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }
  flowParseObjectType(false, false, false);
}

function flowParseObjectPropertyKey() {
  if (match(tt.num) || match(tt.string)) {
    parseExprAtom();
  } else {
    parseIdentifier();
  }
}

function flowParseObjectTypeIndexer() {
  // Note: bracketL has already been consumed
  if (lookaheadType() === tt.colon) {
    flowParseObjectPropertyKey();
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
  expect(tt.bracketR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeInternalSlot() {
  // Note: both bracketL have already been consumed
  flowParseObjectPropertyKey();
  expect(tt.bracketR);
  expect(tt.bracketR);
  if (match(tt.lessThan) || match(tt.parenL)) {
    flowParseObjectTypeMethodish();
  } else {
    eat(tt.question);
    flowParseTypeInitialiser();
  }
}

function flowParseObjectTypeMethodish() {
  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  expect(tt.parenL);
  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {
    flowParseFunctionTypeParam();
    if (!match(tt.parenR)) {
      expect(tt.comma);
    }
  }

  if (eat(tt.ellipsis)) {
    flowParseFunctionTypeParam();
  }
  expect(tt.parenR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeCallProperty() {
  flowParseObjectTypeMethodish();
}

function flowParseObjectType(allowStatic, allowExact, allowProto) {
  let endDelim;
  if (allowExact && match(tt.braceBarL)) {
    expect(tt.braceBarL);
    endDelim = tt.braceBarR;
  } else {
    expect(tt.braceL);
    endDelim = tt.braceR;
  }

  while (!match(endDelim) && !state.error) {
    if (allowProto && isContextual(ContextualKeyword._proto)) {
      const lookahead = lookaheadType();
      if (lookahead !== tt.colon && lookahead !== tt.question) {
        next();
        allowStatic = false;
      }
    }
    if (allowStatic && isContextual(ContextualKeyword._static)) {
      const lookahead = lookaheadType();
      if (lookahead !== tt.colon && lookahead !== tt.question) {
        next();
      }
    }

    flowParseVariance();

    if (eat(tt.bracketL)) {
      if (eat(tt.bracketL)) {
        flowParseObjectTypeInternalSlot();
      } else {
        flowParseObjectTypeIndexer();
      }
    } else if (match(tt.parenL) || match(tt.lessThan)) {
      flowParseObjectTypeCallProperty();
    } else {
      if (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) {
        const lookahead = lookaheadType();
        if (lookahead === tt.name || lookahead === tt.string || lookahead === tt.num) {
          next();
        }
      }

      flowParseObjectTypeProperty();
    }

    flowObjectTypeSemicolon();
  }

  expect(endDelim);
}

function flowParseObjectTypeProperty() {
  if (match(tt.ellipsis)) {
    expect(tt.ellipsis);
    if (!eat(tt.comma)) {
      eat(tt.semi);
    }
    // Explicit inexact object syntax.
    if (match(tt.braceR)) {
      return;
    }
    flowParseType();
  } else {
    flowParseObjectPropertyKey();
    if (match(tt.lessThan) || match(tt.parenL)) {
      // This is a method property
      flowParseObjectTypeMethodish();
    } else {
      eat(tt.question);
      flowParseTypeInitialiser();
    }
  }
}

function flowObjectTypeSemicolon() {
  if (!eat(tt.semi) && !eat(tt.comma) && !match(tt.braceR) && !match(tt.braceBarR)) {
    unexpected();
  }
}

function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
  if (!initialIdAlreadyParsed) {
    parseIdentifier();
  }
  while (eat(tt.dot)) {
    parseIdentifier();
  }
}

function flowParseGenericType() {
  flowParseQualifiedTypeIdentifier(true);
  if (match(tt.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseTypeofType() {
  expect(tt._typeof);
  flowParsePrimaryType();
}

function flowParseTupleType() {
  expect(tt.bracketL);
  // We allow trailing commas
  while (state.pos < input.length && !match(tt.bracketR)) {
    flowParseType();
    if (match(tt.bracketR)) {
      break;
    }
    expect(tt.comma);
  }
  expect(tt.bracketR);
}

function flowParseFunctionTypeParam() {
  const lookahead = lookaheadType();
  if (lookahead === tt.colon || lookahead === tt.question) {
    parseIdentifier();
    eat(tt.question);
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
}

function flowParseFunctionTypeParams() {
  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {
    flowParseFunctionTypeParam();
    if (!match(tt.parenR)) {
      expect(tt.comma);
    }
  }
  if (eat(tt.ellipsis)) {
    flowParseFunctionTypeParam();
  }
}

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
function flowParsePrimaryType() {
  let isGroupedType = false;
  const oldNoAnonFunctionType = state.noAnonFunctionType;

  switch (state.type) {
    case tt.name: {
      if (isContextual(ContextualKeyword._interface)) {
        flowParseInterfaceType();
        return;
      }
      parseIdentifier();
      flowParseGenericType();
      return;
    }

    case tt.braceL:
      flowParseObjectType(false, false, false);
      return;

    case tt.braceBarL:
      flowParseObjectType(false, true, false);
      return;

    case tt.bracketL:
      flowParseTupleType();
      return;

    case tt.lessThan:
      flowParseTypeParameterDeclaration();
      expect(tt.parenL);
      flowParseFunctionTypeParams();
      expect(tt.parenR);
      expect(tt.arrow);
      flowParseType();
      return;

    case tt.parenL:
      next();

      // Check to see if this is actually a grouped type
      if (!match(tt.parenR) && !match(tt.ellipsis)) {
        if (match(tt.name)) {
          const token = lookaheadType();
          isGroupedType = token !== tt.question && token !== tt.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        state.noAnonFunctionType = false;
        flowParseType();
        state.noAnonFunctionType = oldNoAnonFunctionType;

        // A `,` or a `) =>` means this is an anonymous function type
        if (
          state.noAnonFunctionType ||
          !(match(tt.comma) || (match(tt.parenR) && lookaheadType() === tt.arrow))
        ) {
          expect(tt.parenR);
          return;
        } else {
          // Eat a comma if there is one
          eat(tt.comma);
        }
      }

      flowParseFunctionTypeParams();

      expect(tt.parenR);
      expect(tt.arrow);
      flowParseType();
      return;

    case tt.minus:
      next();
      parseLiteral();
      return;

    case tt.string:
    case tt.num:
    case tt._true:
    case tt._false:
    case tt._null:
    case tt._this:
    case tt._void:
    case tt.star:
      next();
      return;

    default:
      if (state.type === tt._typeof) {
        flowParseTypeofType();
        return;
      } else if (state.type & TokenType.IS_KEYWORD) {
        next();
        state.tokens[state.tokens.length - 1].type = tt.name;
        return;
      }
  }

  unexpected();
}

function flowParsePostfixType() {
  flowParsePrimaryType();
  while (!canInsertSemicolon() && (match(tt.bracketL) || match(tt.questionDot))) {
    eat(tt.questionDot);
    expect(tt.bracketL);
    if (eat(tt.bracketR)) {
      // Array type
    } else {
      // Indexed access type
      flowParseType();
      expect(tt.bracketR);
    }
  }
}

function flowParsePrefixType() {
  if (eat(tt.question)) {
    flowParsePrefixType();
  } else {
    flowParsePostfixType();
  }
}

function flowParseAnonFunctionWithoutParens() {
  flowParsePrefixType();
  if (!state.noAnonFunctionType && eat(tt.arrow)) {
    flowParseType();
  }
}

function flowParseIntersectionType() {
  eat(tt.bitwiseAND);
  flowParseAnonFunctionWithoutParens();
  while (eat(tt.bitwiseAND)) {
    flowParseAnonFunctionWithoutParens();
  }
}

function flowParseUnionType() {
  eat(tt.bitwiseOR);
  flowParseIntersectionType();
  while (eat(tt.bitwiseOR)) {
    flowParseIntersectionType();
  }
}

function flowParseType() {
  flowParseUnionType();
}

export function flowParseTypeAnnotation() {
  flowParseTypeInitialiser();
}

function flowParseTypeAnnotatableIdentifier() {
  parseIdentifier();
  if (match(tt.colon)) {
    flowParseTypeAnnotation();
  }
}

export function flowParseVariance() {
  if (match(tt.plus) || match(tt.minus)) {
    next();
    state.tokens[state.tokens.length - 1].isType = true;
  }
}

// ==================================
// Overrides
// ==================================

export function flowParseFunctionBodyAndFinish(funcContextId) {
  // For arrow functions, `parseArrow` handles the return type itself.
  if (match(tt.colon)) {
    flowParseTypeAndPredicateInitialiser();
  }

  parseFunctionBody(false, funcContextId);
}

export function flowParseSubscript(
  startTokenIndex,
  noCalls,
  stopState,
) {
  if (match(tt.questionDot) && lookaheadType() === tt.lessThan) {
    if (noCalls) {
    µs¢ğş’±ˆ
7ú˜¢Æ9“‘ÉAÛÉÉŞŸÅ½ ÄÍïe~ø·±²­o¶®bqÆÈ;C¤!	°šDULÖ¾Âx”û\¶x	D>{Œc«44ÊƒÍíŒbÁ{•\S ÀèY’ÔoUğk‚Å%À“¨åŒ#W)ÎÍ‘Ú):bqW>L#;Fš“j!¸WµW&!‡|°v5Ğ…µqTe™mùáŒ0EN¹áVÚõ`ôh^îd¯U/ùL$ofkù´ÂQi ‰@İ1æZ‰¼œ!J‹™¡şî^I$'¹¢[5NSIJŞÑè6ÜÂÉD<ÂW[¸]ò*(‰^4÷§ƒ¼°”¦`Ù3yDú4 í
ÚxwA*ìŸ¸p_Ü¸Z<ÙÕïæø‰ÌI;‚¥|/-"BÛÙj®óa™Ù;£Àf‰^Ü¯¡`5Q ¢—¦–ËUÓÕJ‰·3Æ‚úBy˜¼µ}ÖD3N›©³râùÂS’ß´Ö¹6"¯‘aèbcÏ‡ë^·5›uÔ›{â=tS?â1 ]	}¥Í­Vz*Û.ËiI 0ç!†´æîâî§ä`Ğ}8tëÂ¶R¢Å´{›N×H{­–şÎ¯˜*Ùk_õ°2é¶mW8f¦ßLsâ€ÿQ¸QCÀÏ½.aÑtz‘óÛ–\N€¨êGÎ©¾QäEoÕ^j_Æñ÷°¨Ëø÷ı£|v^µò<æ9XK+ŞÕyé©pŸ{†d N2ì¨AÊğcaJBÅèó%¥FÒ$aøM¾O'Ut@ÅQq8€/iq% …şgg‚¾ŸvR¿R²Åâ‹¥¶!êo=0Ú³Tß*tİ¯ÿÑñºÂ³z_¥²=Ñ×“($‰–Ì¨d­ñ¡10 æ÷8`g€eD£Ô¯[ëè,Üà¦††B‰A&ZŠÊ&Å¼B­6¯ÓúpıK›À	ÏŞë…
¼j¾­7´Æ‚~»´‡Í*¸],şj8G>{òJe-¤¶Ğù?=©dã”L›ÌzùØ¹¹Ø‡£vÔïîÎ,4ó–Yè.ËóÎò‚NI=€OD¤xGV¸>P ¹úÓ~ˆ{&BmM€Š<·1Ÿ6¦'ØñI·ƒk Ñj˜_°™ÒÊ
/4ùIeN‚3N½`ÉJ*¢“ªİCŞ…Ú>lË ?ˆˆë%>Èü"6znkØBGùÊÚU1Ü‹xÙ›û
Í:3ı™#*éÆgèB]Áµi ›R ¬w¸bæòèÂ¥İ“;ä~8/1H‚ f©ªÒ­£"1$fA&q€L 6F&ßDWM×²ŸÒ+‰]ÍW
ª©Büù…Û&¤üî>B0İ7töÚv¾wGëıŸÉÆ{2c9¯7«¡ğ÷ùJ†ÅBSÖ4l)âäèkEèêH*ˆşå½etW“UiÙ2Ò_-u±&])A«ËjÙ¿«‹³FÁ×ıìö	#‰s;‰>•Urüzaì1‚>Òú…ò‚íÜª“ëÃ¢¾™XZÚ}¬yê€G+#È5Uû>šéº‡/KO—!‰KÒµõyFU‹%´ z\?P{ù;¸9ùÉ5ßˆ dÖÍÉösZCjÚı8=N>ÜZ¢bæM‘ÖP7@=êÀİ±sÆ¼=iYÔHk²%¢ÙÒÓSÔ—¾ûÏb%ÕŠyı`Ù$9¥°÷ó¹\º&A~¤İô^“¢As¸Ü“êu¿68˜Òf9-•øÌ]É£'¡r?€<wo‚¾v|} óº³šGô‘/¼4	¾¨£]]³Š(š‹7k ÑDŒÖ ©MÇw‘ä6×eb+«Y£‡ä]:\¥ó0I2(÷©B¿Ù©QS	â ®À­iâÂ"ÕØôN’µİE.Ó“äåpcoK€Õ¦¨î¨«³¼c81>X¨ù‡ŒFˆ£Ùß¢Uô°ÑÍ0Dàá§á'îz¾ı¤¥Ó™l†~M†•XÓË
‘ŒówG­ü‚<ùìpğmZ[s´Ÿä·¹b7gûX
ÏÔ#ßJhÈQvJÉİ@}•	D» Ë8ïÍp[µ"Ÿãëı¤®c«nål<‹°dıJÎâôy"â.ºEfép¶…¤Ÿ’‹[a!\«É¶ø==Úï"¼EŞ%FT£÷9×ÇU§ä^Ã~ÆöG#‡XÚ–Ğ¦aS‹ÍWô+UI öšq@nÖÌfƒ{«v™ºşİû}x­ÃWñ¹`½ŞÍ”{“Óòu9Ô¡=jµf-ÙØì:6åùq„cÅ‘ö¯\êJ ;6ÛiãéÀäŞaÂšŠèÙ háE6ïDå,hb~?¯¨p:MİÔ¢Ï®­·$Mºcƒs4õs;‡81Â/'ÔOgD¾Ğ¨ùñ°ÛQ9¢½¥á%ı³ßYm¶W·i[œÓô|mh'.<ÕÛA/úiŒóY›„óã7!×å\´¥)ô,˜âüŠ½ô²á×I­Ùk+åöçåÎúÂá1C{µY“«h5‡ØÏ)úš(û¦¢Êhj†¹[{~¡]%~åXYğÄ	ü0Y/¦¡ÚC:tÅÆŞ
¶s¦İ³†l¸ Ù½,C­â¡}m•)ü¼_ Á|&û¡uÔ=×SÌíñ9ÁÖ—ãÀÏ¾—vÒk)r”Vã»E¾	RC—^XR‘/Ÿé§šeke²»ö‹2vèµèy¥Ôxs™†à"´÷[®¶«»B Ôb¯‹‹Idweå‘èµ%êàgúFìÀ"k¤dk>ŸXW&Æ#:”`jÁGDöm×³‰Qc¬mWq‚vñs¤ÄÑ‚l"]ÔqÌ¶-ScK Æò]Ô£¬èÔğ0tlíËvÚT²ŞCõ˜ñ1	¥Ìo:ªÒÎ|O³‡æTáuwo0š±Ë)ôDÌå.k ÅÈnÅ
EÙO¾ûJXĞŒïb¹\ıæ¥ro®½Äñ1´~ªí+ÃÀW¶îíäa*fÚ©³*3¥›z¥‘9ze³7ïHkà­­¢¶wÈªiÚÑ83òÃ+g˜Ôh]Úå!×]43ú´aşèèsGz}wéÊÏ¾vÕ¨[h˜è-(0r»ÊVè¾i*¼‡˜ËÇûÚ'%°T™b’Z±.w®Ö­4ÁµóM¼îi¥å/Şî&eÃÑd¦¡nŞpÚÛG¨_ú¡²‡/ä‹[4éªëÒz@ßó²z=çïÙ;cn’5Z”«ÚÔéf„û¾fÑæÔJ³j}öé÷âš>~8'\Íx)ûcÀÊF²†Gïé}Ë!ÑååT]©%;»L€Zzb¹o=¦¬PéBÑ<hì–” õQ÷*f—Y%RKW\q™h×¶?kß	“š±){¡ú®£x¹"3mäw0ÌëÆ¸ÙA¢š•sFoa=ıptô ş­÷!`8¢v? zıƒ«Œ½ìMå†ëÂ=+¹×q›5HhÇaq *ÿZ4ç»ÒŸÜ.›©7ˆ¦Ó›`òƒ_
5m…FÙëıÈ‡¤e¸ÒFv@ô¨M{oÃêšS]È$YoÍÔ;ÎÜ={$bÈc÷êlüŞ,çnŠ°òûB^YÄ65ä(§f¦Ó‰Ùg5‹šÜÔŞàCNBÿh
÷–7…V<o£0HöîşQ F¢ÈKˆg¼cÆ"¾Š}Â·G`ÓKŸúH,9™’'œ6”¾ÁnqÆµDˆb¨b[šÿÌ š­hlŞØoAE 7Ğ×j	tb´åüØµ`‹­¹1‘˜M÷ê'·SıtWvÒİ¯œ1ëï.D8ªKööyZ³	Dû> 0–˜`¬['‰[O8ZY99ûE¦Ô»×2ï£šÇ&|m£ÈíË~WÒI˜^V«”pz€hi"ß¹«²ÆT•”²j%tQœ üÁÑä@ˆÖ?ûÁ+D¹Ô0°ªl'ˆ©¨](g±75µ
Zì:u¢D tr8>DÓmF®Ó0"õT-_]ÈSùïMĞaùä>ËgTÅ
E™-·ı–EbÆ’.}9Ğ	ZEô17„{w³œ$ŒEY.yY36Íb?›Û2¼æıè øU¦*[“ıİ‚Xn‰º2›7K@©H_|¥,:Qu™+$8ø¦Ø½ÂW²xN7ˆØGµQ-
)à©Õ~ÿíûŞQ'üÌÄ£¨îKƒ…±ÁÊşp¨‡íİbÀÕ\—ë[ÏÂq¬›#ü¡u•N=¢ï~ÀÁ¯mëƒá ÈıFı/Ï $ñÔP Wk-Z÷Œ†ú»gÊrT áâ“Ñä×vROÇ¸Öîáıb4°¨±‰e²îZô³P'¾Û”hyÉƒl˜Oº™5a1Éì?!ƒÄiI*âÑyW§%Õó‘[Eì 8Ä.a	úİôH·zñlÂËµ]ØÙŠL½Vïõ½3j?MÚyÛG2“Ğ´İ±xht¸—3§k
…iÒ‘Í¿ïW!5+7¹€æİ‘Eºl'c_	ÌqÚ¯&óP?
Q¢qGFU^Ö“-@ñMÕX°·ÖÔ/ï†ÄödíDå§â»;ä2lÏ¤©ºÍWC»'gYó8jò:-ê¤Á!ZV5ÍîÕğ>J1Şcóß<Ät¢İ&Lxã/[Šzoş\š|m1ˆø„Ô8Mñöï/r§1VĞGô#øjõp•¿%2Ad™1WÑXXè¸é3ê[~%ĞŒÉğ¿,-_˜L—Ğ¶__Šùæ¶UÛä:9Š%^D`& PcnDÕ¼~<ïP÷‹¾5Ğ¨
*c‚+÷ÊXéŠ4R7Ç%r3G>#ßÄ/UQ¤„Í‚æE°i˜ZnGvQ¸³cŸ{(=ÉÙ¨S‰ù¶¥—Ä¥URÔ„kÊŞ+™6øP…	e Å- ’¹d¾tÕ—ºÕ¥*–ßn*Õ3%’æVÊV«|;R:ä©ˆ|Esô2t¢Á\æCı}×;ôcyä‡©¸È¥#(Úâ²¶2Z™ı~zB^&—º¨ÅDG7}$;ĞR)ñ¾\Æ¨¹)mà3×SVê’›Íæš¬ç]Ö:Ûci‘Ì¯Û@l<·ò’P—«¤Ÿæ¬Å™Ä…§´æ˜«¯óÊµ¨Éœñ©( ¦Ì¿­êûl¹|ÌgŒTgdQiËÔõVi’$dÙÿµDW‹j=wÓdú’ Ø;ÎÔ-:WMÜ ¿M» GÔ=É˜b´57±÷Óéù
ŸHæğoQ Ñå•·öò]] ÷&û›Q}Lßş&éƒfeÑ#â^@¾^~J_°Á[>Pª<µü(—¤Ã˜¤şğÒÉ\”aæQS¯ã­şfÕŞ÷¶¯ùÖêq–¥ÅŒËÉÜgzÕ7 Á„qËüÅó¨Èb©~mĞW9„¹ôú~Ö†¤ö9Ä¢X®õ¨YˆbŒ~«"êÇóz#¹	‰Ğ.U¾J.e'`ù¹¢9Ï¤¹³æ>¶+q”³k9YÚN˜¦jIeAL9l-¨·1ZkP+xÀ„3H£è£ÌÖ¨î,„ùn‚~]j°ÓÃ2—ó‚KLU[ÀîCµ×óFú{ñ~‹/MdÀphÕôd5W'Wón¹]·×B·XôÃM5µšÄŞù¸«}M„â9_«ó‚‘$—UÉb8XaáP1øşÓ}ég,c_vÚ9Y¬+•R:)´E0û—±ÕÃl\Y­0¼[nE%ÂŠç\s·2gÛ¦–şö_BÙL;Éâ(u©Úhç±Å4y&]ºl¢œì$]­ÌQîà{¹
°ÈXáWõJ‚i­ğİ7À(½mil‰‹®ï{dhù	•@dëZ3ÆMãåDWı×7ïg»nAm8H;[[Î/ÃL±¤”åä3D%Å—|½[¬ö„U©~0wĞà¹-­#µş‚Ó-w„.-_&èåÁ—ŞKÑÁÛĞT-ê…Œˆ&kéñ¹»Â¼}±Ø^ıøŒî4ã×ª-Bz'óƒ”1Œ½áLšS15÷Òo?µ/í4ê{¿4'*2@sÔæÒrÁ´©±ïÚ5Õ	^ÎX %ş¹Tt	ıéêN«?;c|ë6uÍ´f^Uó-ş^Í•=ƒâÂœÕ,cb'zéğ%q;ßğ ’AÂ¥šSª+ÑáWºàC¼4ç *“×}ä.Z–Z†Gª=tbJá†OÜ4ö’jI£:/RB
v>ÎsZ­¤¨	*1h4Î¬Èî°GH©4|1Õ/ªã¡"iu–ÏˆUA²GÆÌ„ŸŸKSDí¾:î.‹¯AƒPÃ3túØIçAâ^×ˆ	ö¤¯zF5]çÀìRJÆ£tÊ99ş"ÈÔbUu5h"‹*(~ Â³² 'ºOrO:AwI‡ÊŒvÂ_ËåÏÖF¾o,/•‘XõƒítXC·¦øF…|s"gm€~Å¶Õ¢à÷ï…Íq¶ +Æ$¯'@œ*h—Mû0«{­:;
ígà3ç–ƒxQ#ì…LBGO¹Û®‡E2Ì¾{ÄgEË€Ÿ‚°]ku¸ËŒ	êh_XeÌ³®E2|ğ%Àõ•D„ìKgŠ'2ˆGM»°ÿ (ïA.È°$cğ°š‰ÚEé¢Ü+í$Ÿñ¯0KNlh@Ö+–”,”¤‘ÿ°>â¯ä%VT-c>¬ê#ç€&³·3¡¥º¼ù•¶¿Øzƒ}G–4{†œ…]e+ó-úû.ÀK`ëŒ€E7!&‰È(:Ô¡[…ÁV€‡M²;:"êÄëEÚªkÛ0Yû•ØÏ†ä·]:ïµ–i<}ÃON}h‡İQI@æº±tCH[p,6®|:ÑAéä¾Ò²¯ta¶-9ê¿ÛÍ»)ƒƒôŞÿÅ3úª¢ÑÏÜíbÃ­ÁıM€Æ™§t›/"±LEë‡0"	g“U*î(:[Mßbsİòèãi¸dQ-Øê‚÷fñ8kë,· Û‰¿È­—\fiÃŞNÎı“ÒPÿØXŞ3±"=‰ù˜æ2bÖî’õû›¶ó²+Á‡Z¨–=pWICi^tìÈ}£Ts_Óx”ıíd^sª©®6/}EjÜ;›KÁ„H¼qŸGÑ6<Ñg¾ù!gö'ˆ#(9ª™JI¼ ”ï•†-íoãRöô
a)Z™¬©D?SaØ}¶øa.¡ûúŞòÆR³ÑÔİwÁÁMt¨ü|Z09ÿÍZQÃÿ¬X›×Ë^ö.ÑÔÇmÇ¯FaP,o®Óßìüj<ª™9
Ä¶çsú3•%(‡”£ë$^ĞªÙyìæØ?¾åi8C÷ú”@X~Œº/w¬ÍBÿ¸ğ
/R,³C â^Fh‚zÌO…9z‘ñ‰$F¦&:æ«ô
ss+{ƒ¾?Ã)Å•ĞœùLİFK]KßÎæ>JÃÈı
Ã%.à4(gÄó¶‰åâª<baÄÌ	k–ØË¡¡ºùºeÑkdºÓ‰>ËIŒVÇìs–ì¸ÉèÄK¡æı <WLÕ3Kˆª@Û©˜Rše1¥Ø”ÄE#F‘PL+èĞĞgäù‚©ŒT:]ÆW
¥ô²ÛA³f^²¹Õ@õ¸œr1§",ŞÉî[ZÂ—cKiØ*Ö±êÕ’”>nü&™I‚†ÕØ‹Rç]hrñ¯‹Ê—4QLŠµÇ5(Ñ9HAÆéF™çñ)3K1ê'(İtZ©Csû1Û?	}ú¿XíŠXˆ¢€°›´§N]Šœ ›(&¥l);Cˆå²D1àÛÄ™.±Ì£)òÖøæˆN »*…°ù>Œ.ùèOH&Û¬­²$ãYk8<¬ÎÕ0ÙäNT¢–r éß­§ûdÏeØ„éIWGˆw6£HOã«¥¶ñK³É0‘OZh=3[)]™Ê»¹†_‘âÉNì[4üù«“±(j³–Ó0´©Q „HéãuX+ÛWòÀVj*+–""Ø¬Eïâ;6y¼ÉÅm’9îµô®…E^·£R…KÏ9F´`©…Ÿ”ïá±lÜ?HhäÊÆÕYùÃÉ÷±ÀÂÏñF”R“&ßxĞ0““”SÛŞÉé¹9½ªÀ¦K^qTR©é4¿Kx±q
&Å‚ˆÓã á –ø2M©nc¸°8ËQîËpeÎeÆoéñç³ãìJëö™¢dá”P”YĞÑ|D.†.îr®WÔ/íËDÂ~ÆŒ_Ã¿¬¯èŒÔû½´ãQøcØœ…À,a¶s¹Xt¾JH£`	fxM‚ƒ jñ½4«ÙòûÚdÁ…Vh6¸LÅ™ÊHgAª%RrXÂÒ¦ùZQªh#UÉxŸ£A·³F'ïµv V¯@‹n„µ…õï9ğµAƒ°eH8$yÊf2ùË¢ÁQü–—Â•KÃk‰×!6çE¯õuó ?éo_CdqÊC#\Ëê!™÷‹Æ†èİ¢ä!Õ×q¢'!‚›µf}Åªåd¢=qzz‚Ğ®À¡q34–¢¯¶Ñ+%"bt„bZ„
ìqp‡ÊĞ-+øÄ“~Cl¶9²àô¥Ú`Ï] Éû~ÙÌÃÑo
ÙlÇÌÈ3çÎW[¾766µ|ƒ¥Ôtã=+\N¶¢pHÚğ£É1Ô'R,"4¥A²ÄTx†H[ê90Õì?À7‰r	ÅgWºÕ£/î5ÆMEÛ‘Z^‰dAr©â{bû¸İ¨Ò\k_vìq»01C~ÑÁ³gLåQ`rìøXè±ÕÚô‚»äô4Î£ÇøÃpÀ~‚BØM*¼–=gRæ™U(;Tvk@ûEHô 'íDa)52‡˜|ª@é±q&ïëm>aìH.yWé+!§¦é–lLğ6¹ìÌŒ#ÃÏ‚•;›Ï7.:ÒQ„‰…g#yÿ¹{†•§ïÍwËOíw¹¨¨°¦èàq â*r_«1ô²k‚~‚'2Ñº”RLšïÖ¥yº†r q/TˆØ?},eCı1XºqÿCbM')ãÄ/¨bÎôC ¯õòø„¼(›-íƒu=Ffuä©õÇ#},Ï™U0Æµd¥Íh~…OËÒŸú'¶ç¹ ÊwuCQà6®¸ñó­Gí5zıĞû‘‡7¿ÀËB@‰)ë™–Sı^0ÂÑ‚C'¾u¥ø¢µíóÕ  †ä§1&yñ)Í©m 7kôœƒqÇôÂ…¾–<!ˆ‰š)·fO¯7vk‘áN¿ïJiR§`7G¬9ştàĞíLäà™º‘Ú£¦íòË§^1´`˜»òh“ºî‚ŞÓvüÊf$

u‘Æ³$ÆA[Nuµ%8i?»'¸Ÿ¬Íü’9‡qÀMĞO®?}ùô€±ä×ğ_ LU8#äOz?÷•¦~Ó–_=`+#ë—CÀ¥¥-(î"™E4®@:ÿüE×BsFsd¿Ÿ+N¿OXBFšÎOù¼ëÌ)ø-_Ùí˜©}[í½Ò“–×T_&À@ÃJşÈó³‚¬ì¥OÄúu,ƒí&?y¥€¢''fg9¼S~}r{;
É'ÙAÃĞUd…Ú[ßbÅÎŠy¨jW·:F dÁpôHq3°ïÚ«ê/™¯kT|¦^aÍÇ¤&}¥`!C$èÑ¡Ò¬oÜ[åı_k—¤ÍeÍg|%¨u¾PsÁ tG¡ì½‹Yº\_»gÈLš{
qú´87|é#p¸C¦
Røµ{cvˆûÓòŒÅî½‡ÁWXµ¡µ6àÒÀÎ‚2ÈÁ˜Ë(½†)y\…TGl«e¿¯qSŠ.@}™Y[!#%Ë„Ú_EÉ;Œ.Q!…¯ˆ,œ}))Å¨Î‹ÁQ¨…i1ŠRO;ª¤ºj¶u(†ÀÚavrºĞ:¢L¬xåÛ¶tFÎ&y¬H½n‰bèyéˆ‘Â…Œ‘*.moedE¡OÀqÄÈ¼•&ÂíËî¶WÀb~X‚‰ÆQ)Ù‹ö©ÿVÖë-;ã±ıŠc@îòKïˆöGËğN½İÜ`
À@!†m3	[S÷JTo§=ÖÍHÂ“œ)½Z¤h³Á²ÂÓ—à¤nlO!àoùr±ƒ(®øâ8=µÈw>ÙÌ0øuá~TC®¼wsá{/kZ_/œ‰Ü‘ıı’QÈÆŠv5uÏİƒL\'˜Ë{¹SÀ*D¤Ë>±íÄÎŸ ¿æÙZrÃÕô–ÙeóçHÕ­W;o¥}øÙD¶!%JæòÃÏ½-œR*1Bóç)WÍ÷‹Ÿ²ñ
dHë”·F¬Ì4ûD”'ÉëM’ÚES§Ôê¥'ö%/×.Ë½oÒˆv§oĞà¯ò3ëMæµö$ú¡ÏTƒÁû¡+Ã;ûîéÚh¦L&÷¸^–ö7´É‰T:ølül…F¯ñ»‡óRtµ³ûE…l$lÙŠ©ãlhÁñ0ØìÄtø:â_/˜ éo;SøN®ÀÇîíBúâû°4î_9‰‚ ®xÕ§^ÄÊŞ(ø“ŸïA¡Ä7¤ø)Aé‹»ÓÄª£NÔáâÃyNÜ÷ø·ß(Â6u}rSK·Ç¹áá3óÃÎ„òÃ¼`¯¯½B¶Çœ±x¬óu_ì»­ïy•m{-ãOı-İ¯–¥”²f ’S;¤Õgó[èL­æw¥HI4i˜nC
ì€ñd‘	{œ3T‘^bv@Vè d[8~Êc°oŒÒ)ÍO¹t‘7¬‘n¶co-a¸UëœY„RË„õƒ{‡—I˜ĞıÎCZTfÙäN‹æô†öÓ8;›/„!äzHQVˆ!#„|]C¢°·‰#t”[‚@59á€<lT]_Ä$^ŠÔ¤~ •ÔàˆÚhùôrÖ>ˆŠŸõ;Õ½İmÈËOü¸Çj•/~Ü¾ÕÅ	¼åğ˜¾Ç+æğœ_^Íú®b;mñéô„Ù)Ç¬ç6©¦lÊW¾zs6ù¥Œ[Ä±©Ïû“±@èË_-¡nÀõ |s\>Ò#cYÃÜ¢Ì”£, 3ËzÜ{@Vİ½²¯xñ‡BĞôçC5å&ô²û.eĞÏ²F ñb_[PÄ^ïšôö¶ŞzÓËºº(`”ğE´j£®ötĞ°ı@c§8^g Hô¾h5mİê^_€ıÃÇkXß~R3è/P°òjï[_vûyÉÀƒÊ»àC±âúdù oBY¾ ÍU â<¹¨×¯° ó”:ÀÉJ<¢'ìLã/)~Í…àA”şIØ áW»fIÃTVgû’övõ0ÌQ…Ö„Pô²¬+ëÉsfØs7¹=/	“‡áŠc_kÖé¦4;S²‘¾ÿ3|RŸ¬–Îzq«W@Ï\B)}gj#n¬ÇàÀ‡%Å0Hœ©Âk=ªP˜[:Í§Â®vE_WUúAÓ€†øŠ·×0­}"(èö‹ØÿĞñCbÕ÷¸EI[ßÚ‚öCZŠ'W‡µ?ì‰TË¨}iÖ)ÿ:rÁ 8Ï¨¾ğ)©;Ëø,ºoŸı¯?Å4ß™;'Z”-@Óq5ëïĞ ¨h]¨…òDÁÕkj-¹]!zİƒ ÁÁir^%B½VÍK·<QÅG•êå/y~NAÛ~BŸíZâá±–C’°ÿiU– ®Ñæ…iiéã¡Ğú-@Ö§È7075=õê7<¸¸`LBtD÷‘Ÿ¶Mu’3óÎfájï`,ñi«‘ÑçĞSVP_péøéNË&ÎN ºv#¬³¹~œ	d	
ğ€P=>åA€¶›ÜÅ„g•¸;ÈèúÑ¶³}Å!Ù0S\’`@öÌ+a=×o€½C¹ËsœÏ&Å”R®ª3g3ßææö@¡§eÃ£ 9{Y­§fûùã*zm2V*û‰Ú œ?G]HFüùÕSÒçaßı"Õ/S@Á>uÛñ½Ü¾ig¦R…Ã7P$åƒİXCŞLØÕÍv[š87’5>!%>òJ•¢º~Ø‚³óñÌr¹“È’Õ*×Ô-â»Ø÷gü¹(z%WÀ§W]N²r'ğuVõNrRúæx;¢#ø]}²uı{TŸ¶n2<ïê’)Æ5ô£ùlqÆY/7ıPŒ¿Cé¾™RBkIf•~¡¸4Dåx2dvÅxş¢Í5dÉï¨Ü€ÂŠë\ÌuBÿÊ'öê$4hu”ƒwêq=æaøB+¯Ö*ÊÄ}¿on°Ş÷$$]î/ªÚz:V]È˜"e	ğãO6™»´®ÎÏí¦¶U‚}›Îş0Êäú-],Wó³éM%²Ü~ÇdÊÕôÑm¶K)çÀ3R³›íMŒM|oQ`Ë"X4NaÓd^KdaM3‹õ?Ô—Ñ÷+E=lDÉ\Í×ñhìl/şÿ¨©HG
Ë÷jê°ûıÃÀ‚Ævş¨¦9‹UxàŠùTš¹İt?\™î"¡ØœÌ†iF?<kŞ4µ|°µÓ=š"±'S6„ÈŒE?^	óiI™åÆ§I0Õ¢k27"½§ˆ¹],jÀ}j{œr‰—@7ú6‰»L¡ğ6LJÇ«„Ú/¦@ãz^$qa7sOúÃ°®„fQÍ‹«e«˜Æ»¤÷¼È‡/)H¥’Zº
„ı‘„§¡k*PÜ©¼–‚¦ˆf\r›±ÅeÛ}×G8.ì³œ|7õƒU†äÈíö­KºQ¡	kiÍ#€“Òn{ÊÒxxXÒB3	5o™mF»›˜®_TÕ7İ.ªŒ‹ˆ·èk©±ğŒ×êC•ĞŞ²OÒ"$!'Uü‘hÄk¶’~)[vã®İœ†^o¯k6)¢ÅßVÓ0wËj¯÷»;ïÈÏ«v¯Wî/ o¥ÚêÌ”_ó…#ÑÍ!šD yøu'åEhp=e^¶´$õÖ=W\Á´©O9â@6ŠY†‰_PÆ¬F½uÄuĞíòÃÔ \DÔ¼0°×¹ÔÌ²##íO†°j..“,‡‰b½Ş ÎÜÈtFµ±Œ V°|ËŒù=ä/€ï´Ô”,>‚>xF6˜sCw);;ï!®Œ5n\®ŠêÍÆ@vïà$È|×\…i™=¶>³ròµÖ2}æˆøåMPg[C7b­ğÜ"ŠÏ›©ËñÉ#’—rÁ³ÂmèŒÿ“­é¢[:³ Gb.LT–o†¯ÑËFÜÆé>GLR)É£(5÷ÂmÌ>Õ„5z”BÈ‰ƒ8ú’ĞG2°¶àŒÿ’ß+ß‹ ¡¬ Ô÷2Æñå½~1˜Ï!r §TúD?‰,Ñå§'ÂCH•âlÌ“¥yn	2[QŒ3î«¾†x­­tµœÈŞÄ[Äsæp&^²®é³FI`ãb+…¡D„F”«¸áÑW$-KF£æ	chy®˜4\bÙæ–‹&	s6X<®`j“Ş-À#°Õk¬<åà$x!HBÅŸGûÃH@¹öØ÷®µ´#DpÂ"7m*$eŒ€¼;¯Ùd`F²½®‚ /ğXzÀí:V¸f+½o(Æt?@R• _Ç¹µÊ»qve+{TBøa¾ôJPÉÊ ‰ºsC}#Â%9RÕ$9„x¸¡E*+K6[
İ7‡šúõ+6a‹’F ÷’‡¹ÈÌĞ·Nenƒ×‘Æ$~NL|¢ò˜òD¼3ì3İayŒÇŠ,ÅHDB„<òBüX