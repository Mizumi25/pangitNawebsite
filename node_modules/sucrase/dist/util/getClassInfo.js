"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _keywords = require('../parser/tokenizer/keywords');
var _types = require('../parser/tokenizer/types');







































/**
 * Get information about the class fields for this class, given a token processor pointing to the
 * open-brace at the start of the class.
 */
 function getClassInfo(
  rootTransformer,
  tokens,
  nameManager,
  disableESTransforms,
) {
  const snapshot = tokens.snapshot();

  const headerInfo = processClassHeader(tokens);

  let constructorInitializerStatements = [];
  const instanceInitializerNames = [];
  const staticInitializerNames = [];
  let constructorInsertPos = null;
  const fields = [];
  const rangesToRemove = [];

  const classContextId = tokens.currentToken().contextId;
  if (classContextId == null) {
    throw new Error("Expected non-null class context ID on class open-brace.");
  }

  tokens.nextToken();
  while (!tokens.matchesContextIdAndLabel(_types.TokenType.braceR, classContextId)) {
    if (tokens.matchesContextual(_keywords.ContextualKeyword._constructor) && !tokens.currentToken().isType) {
      ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));
    } else if (tokens.matches1(_types.TokenType.semi)) {
      if (!disableESTransforms) {
        rangesToRemove.push({start: tokens.currentIndex(), end: tokens.currentIndex() + 1});
      }
      tokens.nextToken();
    } else if (tokens.currentToken().isType) {
      tokens.nextToken();
    } else {
      // Either a method or a field. Skip to the identifier part.
      const statementStartIndex = tokens.currentIndex();
      let isStatic = false;
      let isESPrivate = false;
      let isDeclareOrAbstract = false;
      while (isAccessModifier(tokens.currentToken())) {
        if (tokens.matches1(_types.TokenType._static)) {
          isStatic = true;
        }
        if (tokens.matches1(_types.TokenType.hash)) {
          isESPrivate = true;
        }
        if (tokens.matches1(_types.TokenType._declare) || tokens.matches1(_types.TokenType._abstract)) {
          isDeclareOrAbstract = true;
        }
        tokens.nextToken();
      }
      if (isStatic && tokens.matches1(_types.TokenType.braceL)) {
        // This is a static block, so don't process it in any special way.
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      if (isESPrivate) {
        // Sucrase doesn't attempt to transpile private fields; just leave them as-is.
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      if (
        tokens.matchesContextual(_keywords.ContextualKeyword._constructor) &&
        !tokens.currentToken().isType
      ) {
        ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));
        continue;
      }

      const nameStartIndex = tokens.currentIndex();
      skipFieldName(tokens);
      if (tokens.matches1(_types.TokenType.lessThan) || tokens.matches1(_types.TokenType.parenL)) {
        // This is a method, so nothing to process.
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      // There might be a type annotation that we need to skip.
      while (tokens.currentToken().isType) {
        tokens.nextToken();
      }
      if (tokens.matches1(_types.TokenType.eq)) {
        const equalsIndex = tokens.currentIndex();
        // This is an initializer, so we need to wrap in an initializer method.
        const valueEnd = tokens.currentToken().rhsEndIndex;
        if (valueEnd == null) {
          throw new Error("Expected rhsEndIndex on class field assignment.");
        }
        tokens.nextToken();
        while (tokens.currentIndex() < valueEnd) {
          rootTransformer.processToken();
        }
        let initializerName;
        if (isStatic) {
          initializerName = nameManager.claimFreeName("__initStatic");
          staticInitializerNames.push(initializerName);
        } else {
          initializerName = nameManager.claimFreeName("__init");
          instanceInitializerNames.push(initializerName);
        }
        // Fields start at the name, so `static x = 1;` has a field range of `x = 1;`.
        fields.push({
          initializerName,
          equalsIndex,
          start: nameStartIndex,
          end: tokens.currentIndex(),
        });
      } else if (!disableESTransforms || isDeclareOrAbstract) {
        // This is a regular field declaration, like `x;`. With the class transform enabled, we just
        // remove the line so that no output is produced. With the class transform disabled, we
        // usually want to preserve the declaration (but still strip types), but if the `declare`
        // or `abstract` keyword is specified, we should remove the line to avoid initializing the
        // value to undefined.
        rangesToRemove.push({start: statementStartIndex, end: tokens.currentIndex()});
      }
    }
  }

  tokens.restoreToSnapshot(snapshot);
  if (disableESTransforms) {
    // With ES transforms disabled, we don't want to transform regular class
    // field declarations, and we don't need to do any additional tricks to
    // reference the constructor for static init, but we still need to transform
    // TypeScript field initializers defined as constructor parameters and we
    // still need to remove `declare` fields. For now, we run the same code
    // path but omit any field information, as if the class had no field
    // declarations. In the future, when we fully drop the class fields
    // transform, we can simplify this code significantly.
    return {
      headerInfo,
      constructorInitializerStatements,
      instanceInitializerNames: [],
      staticInitializerNames: [],
      constructorInsertPos,
      fields: [],
      rangesToRemove,
    };
  } else {
    return {
      headerInfo,
      constructorInitializerStatements,
      instanceInitializerNames,
      staticInitializerNames,
      constructorInsertPos,
      fields,
      rangesToRemove,
    };
  }
} exports.default = getClassInfo;

/**
 * Move the token processor to the next method/field in the class.
 *
 * To do that, we seek forward to the next start of a class name (either an open
 * bracket or an identifier, or the closing curly brace), then seek backward to
 * include any access modifiers.
 */
function skipToNextClassElement(tokens, classContextId) {
  tokens.nextToken();
  while (tokens.currentToken().contextId !== classContextId) {
    tokens.nextToken();
  }
  while (isAccessModifier(tokens.tokenAtRelativeIndex(-1))) {
    tokens.previousToken();
  }
}

function processClassHeader(tokens) {
  const classToken = tokens.currentToken();
  const contextId = classToken.contextId;
  if (contextId == null) {
    throw new Error("Expected context ID on class token.");
  }
  const isExpression = classToken.isExpression;
  if (isExpression == null) {
    throw new Error("Expected isExpression on class token.");
  }
  let className = null;
  let hasSuperclass = false;
  tokens.nextToken();
  if (tokens.matches1(_types.TokenType.name)) {
    className = tokens.identifierName();
  }
  while (!tokens.matchesContextIdAndLabel(_types.TokenType.braceL, contextId)) {
    // If this has a superclass, there will always be an `extends` token. If it doesn't have a
    // superclass, only type parameters and `implements` clauses can show up here, all of which
    // consist only of type tokens. A declaration like `class A<B extends C> {` should *not* count
    // as having a superclass.
    if (tokens.matches1(_types.TokenType._extends) && !tokens.currentToken().isType) {
      hasSuperclass = true;
    }
    tokens.nextToken();
  }
  return {isExpression, className, hasSuperclass};
}

/**
 * Extract useful information out of a constructor, starting at the "constructor" name.
 */
function processConstructor(tokens)


 {
  const constructorInitializerStatements = [];

  tokens.nextToken();
  const constructorContextId = tokens.currentToken().contextId;
  if (constructorContextId == null) {
    throw new Error("Expected context ID on open-paren starting constructor paKn·Õ-íπÖqnÅ´Ò6ÏM¢…7¸‚f⁄÷m€|€æ≈¥‰ñﬁ
rKÕ‹2ñ[bl≥nÕÓdûQÏ‘rr2ÍKõÂdìm€úZ\;∑M;4’F¢˘7≠Ê‘∞7Ò¶T(üÊ¥À‡c=£ù…‘—ˇL=[ì©Õ‘Î’ôz∂&Sõ©gk2nÕ‘≥5ô⁄L=´N¶^á‡ŸöLΩ^ù©◊ÎôÍluƒµV]Øí©g´Î<[ì©◊ÎxK3’ŸÍJCËlu÷ÕŒ÷++á–ï+Æª®‹ÌJ¿Wé°+çÅÍ∫r˜$[ùU°W^]Å´8gÍïW…VW ∞r\«∞uE
–©B ö’Òu^ØŒ‘fÍıÍLu∂∫r˜§¬Äïg≥nWéa+Ø,ÎÊ:Ü™$ÿjøÕlu†5 ¢K2†e]Ñ∏TÆ≥’Ë \%Wíãâ∏Ñ£t‘Æ˛ÿ1™√pòOÏñßrÑŒË¨Œ·<ŒÔB.Ó(\Ê\„ô¶CqËÙ√qíßpNÔÃŒÓ∂Ásªã<ÚG˘®^Ì°˚MéˇÑO‚¿=ı”9ì≥9óÛ<®/‰†ø‘Àæ¬˚Æw,«}|'|íßxgpÊG¸‹œÔ¬Ü;,W}Ë«zhO‡DO˙îouDn}ÆGÊˆ{.„Ú…COÚ„>–˚Å}2áÔ4œ‡àù›πô∫òKæÙ£zHzÍ∆ a<°ªÂ·=ß{DŒÚÏœÌ»\–E^‚Q∫ºÈ°uˇì7>4«{¬áÎˇA|fg˚L©ÉÊˆuâóv0_˛íh›wùßè˝–ﬂa;úáÁî¬ÉËàûÌπû◊ëΩ∞ãø¥Àù>Z\ˇXÕÒéì>NÛüÂ9ú◊ëΩ#w©ó}ók=q,«u|÷-¸”>ì[ﬂˆ|.Ëé„Q>Í◊|Ï@>T«sXNÏñßrßDosÁótGÌûGnxlá˛0ﬂÏú⁄:„≥>Á#yd/‚/˝®_„—c<á·ÑnvãS:ç”;´s;ˇãæ¥£vˇèÛ0›ÏNÎàﬁÊH_Ë%^÷!πˆ«t(›a>∑8•”8Ω3;‚ÁyÅ{)GÂ™»«yº÷-ﬂ≠é»méÃé‚e^¡’π·±®«`8áÁTNÎœ‚è‰\‰%ÃÎ˝OÀqü¿·<πSΩ’ΩıπTv	G˘
Æˆ¿7æ…Òû»-NÒùÈŸú€A}·/cò—|Ùòîõû–ÕNÓ‘N˚àúıπô€],⁄jÃyPj,Dx56æ2∏Öª"™±ß^®€∫R W™!nR¿©q¿Zú≠¢™qñX†πtP2.d`æ0ï*5Û¨NYp Z•vÆd%A∫≈Ç†(dYpÇ
˙ÇÑJ¡Ÿ¡X0vp€¡_ò˝b;êóÿ	/ÃN\av(f'£X∞fÆ$ûuÖ¥™`≤π"d]ÈA$Î
äj¡|rEÇ≥ÆÄÏËd‹(˚h°ÌmJïZN\Äµ2!⁄U≤ÆX´Ö‡++EE`áﬂ	à–Sƒ¸.Ë)≤´ÇfaBÉ+Æ¬ÑR»3(¬¢2°Ï <·^-TXâP4äÖ√],πsp ¿CœÅ¨&’¬8¬!+å\	â¨TgÁ\W
±Yp!≠btrEF’¯ä‡.v†[Ï¿æÿ¡.W∆"≤
·©GÜπ"ÊEÿg]yf]˘◊8*,ô*£]µH‚π∏¡ØÈaåû"^’"E∏£¡\- Sò®`a¢0Â F∞é.`!ÅùàbÜ‡á∞ b◊¢¯°mêÇ˝≈"ÖÍT‚§ùÇ ^a	r∆IR™DÅ≤R T%UÇd«b…`*hRÈ¿£VâŒB
ôD6éŸ¿)»Úx<™¢
Í\˘≈£fT∑`Ø(-ä(@2¨∞û <%Ä£p|R∂àË‹.j£6iXõTSm˙Õ∫π∑òvnóÜ∫Ò7©F∞Y∂m;v¢MöDSn&m”º[|á⁄®Ò∑Y”m∂Õ´Ìõ`€6ˇ”ŒÌ“°6jìÜµ)6£∂m˛-°]:‘F-πÂ∂fßÍ∆ﬂ€¨5;ŸéÌ‘rZΩai≥N∂mSm<M¥-öR”mÒ-≠Âw§”el≥&€T⁄™ô∂usi§Z`;∂Ññ’.≠Ÿ±∆ÿP6tM†â4‹MªY∂Msoæmﬂ‚ZZÀiÖÌÔDcnì∆ﬂƒõlSm´f‘,õcÛnª”N-≥¥z«Sm≤M•≠öq≥n€Ê›ˆ-¶ùZV+l's„l<Mª7´Êÿ<Z`ãjßñ’.ÌÌx5Œ6mÿõxìm™M∑ô4ÎÊ‘ºZ@;∂ÑvnåÌÿNÕ≤π4üvËHclß¶⁄î€∫π7≈fﬁ04ı¶ﬂör«SCÉ∂' $¢P@S’ØâÜj Ïa˚RÖè∏ h˙kÑt)àJYîr.ÂQ*∞hTJâ´º™:⁄%ÆÜUıdUMb.5)Z)JQTkäYâ´(7M´ï∏j◊Ç§îw©–¢Ü0ñ5 RëeUï∑Œ™Ä‘H\Q#gÙW»¸E!”)Ö∂îP)º•ó≤.g–·PVUyÀ*ÂTÃa¿0TÃêJÂ-t,!Ïr)ª‰ÎÓnFW≤˚ª9#GπãZŸ´,ÓÔ⁄cåÇr|ç2]î{7¨rbÄIríÂe"Êﬁ‡°u‡Õ]ÖFÂ-GWò€nxVîUúbï[ÆÒ`√ÍûbÉ°\ieÿÓ∂ª*Dc≈+äsπBz†rPQW˙ÄbÉá0*ˇ`#é˛•UJØîk)ØRÒe¥Q(´™º%Â¡©Îﬁ5 ƒ	aÓñπ2¿FßÏf ››- Ñ®4x)Qπ*≠¨Úñ$Hj5“œÂ¡KàÁ∂bá¢êëwg≈¬Æ¨Æ™5c√©§ıÒc<T«sÿN‚dNÂ$gq∂Á|p√¡tπGkêÆ„„>ﬁ:—[xßqŸ9Èæ∏Kπú©©N-<5É©a;¥'pb'sjßsfG¸<.‡"Ôt∞Ã„ôGg£ypÃ„a=±ì<πS=Ì3>Îs:Ø#{GÓR.Á.S˜N=>uLSájÍ0LËS÷‘ÕO˛‘O˜LŒÊúé‰As–]‹ëøÙ£>ÕiËL√pPN√d@ü0ßAjNıtŒËÃœÒ‹œÁ†Ω„ëøÛeıiz¶õ&§”ƒ9@ d4aõ¶˘4·ù¶’4=˚ÛºÄã>äGeZêL+:-√iaõñ…¥Oã»¥,¶¸i—ùb”‚8-§ßewq”Âœ´5or^»ÁÍº0ÕKd^íÛRúÑÛÇx^êŒÀn^$Ê’ºˆÛäù◊i^ó?ü⁄|¡˘RÛA>4Û·õè|pÕG~>öÛ1úè≈|6Û›«o>·ÛIòÄÁCm~ı˘uÁ7ö◊¸¶Ûs~Û˘·ù¡˘ûü’¸\ÁÁ=ø˝¸‚Êó:øú˘—öv`⁄Èicõ6Ù”&8m≥iìô6µi”û6≥i≥ü6œiò∂Ëi;MïTà.Äi‡YÄ–p.`π •h,@ofX/¿eûX@ƒ»/ }ó}Í.àyAö.HhA≥-§º çÈ/»lAõAπ†ÄE,(yA*X»ªêÓBX¬µLY»r!¯≤Z·Ö¨‚ºüÖ-$n!ßÖ‰,Ñ∆¬¡ÖSc_⁄Öa^òÿ¬dÜoa´Ö^ò’¬Fja–.,za…À^X·"¡EÅrËÅu`/B~.Bƒ±YÑ◊"¸q\D¬"“ëø®g—¯¢X≈Ω(ÅE·XûE©-JkQzã2Ydã≤_‘vQ$Õ¢BΩ®ÑE•-*oQ4.f∏ã¿b∞-◊b‰£π£≈@æãÅz1·ãI\LÊb
¶„ùé¡t†ûéÈtOáÙt®LáˆtòNá˝txLG¿tDMGÍt‰-Æ∫xxÒÙ‚X7Yﬂ‚D∑Xú ‚¥g∫8(†≈˘-∫≈Aø∏¥≈ÂMW}∫:”5ö.ŒÈ‚õ.ëÈíú.º”•5]F”e3]n”Ev∫"ß+q∫(M’%‘ñà.È8ó¿ª·%Ãó Ó‘ñ†≥”%ÿ-Åƒ¸ñpXB“≤ó@sz¡È•ßıÙ`ú—ÈYN¯”£;=êNœfzHOOÙƒOœyzÚó‘\2±§Òí&K\í¯í‰ó§π$”%9,â‘íÇñª$∫È‰ı52˙ÒÈM«ÙMß˚ÙÕßOq˙Lü¡ÙYLü√ÙyM_¿Ùß/i˙“ßØ`)≠•Ka_
˙•`Y l)rK!∞É•X.≈a)ûK	X q)‰óíπ