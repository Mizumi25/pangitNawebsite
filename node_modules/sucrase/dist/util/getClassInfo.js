"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _keywords = require('../parser/tokenizer/keywords');
var _types = require('../parser/tokenizer/types');







































/**
 * Get information about the class fields for this class, given a token processor pointing to the
 * open-brace at the start of the class.
 */
 function getClassInfo(
  rootTransformer,
  tokens,
  nameManager,
  disableESTransforms,
) {
  const snapshot = tokens.snapshot();

  const headerInfo = processClassHeader(tokens);

  let constructorInitializerStatements = [];
  const instanceInitializerNames = [];
  const staticInitializerNames = [];
  let constructorInsertPos = null;
  const fields = [];
  const rangesToRemove = [];

  const classContextId = tokens.currentToken().contextId;
  if (classContextId == null) {
    throw new Error("Expected non-null class context ID on class open-brace.");
  }

  tokens.nextToken();
  while (!tokens.matchesContextIdAndLabel(_types.TokenType.braceR, classContextId)) {
    if (tokens.matchesContextual(_keywords.ContextualKeyword._constructor) && !tokens.currentToken().isType) {
      ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));
    } else if (tokens.matches1(_types.TokenType.semi)) {
      if (!disableESTransforms) {
        rangesToRemove.push({start: tokens.currentIndex(), end: tokens.currentIndex() + 1});
      }
      tokens.nextToken();
    } else if (tokens.currentToken().isType) {
      tokens.nextToken();
    } else {
      // Either a method or a field. Skip to the identifier part.
      const statementStartIndex = tokens.currentIndex();
      let isStatic = false;
      let isESPrivate = false;
      let isDeclareOrAbstract = false;
      while (isAccessModifier(tokens.currentToken())) {
        if (tokens.matches1(_types.TokenType._static)) {
          isStatic = true;
        }
        if (tokens.matches1(_types.TokenType.hash)) {
          isESPrivate = true;
        }
        if (tokens.matches1(_types.TokenType._declare) || tokens.matches1(_types.TokenType._abstract)) {
          isDeclareOrAbstract = true;
        }
        tokens.nextToken();
      }
      if (isStatic && tokens.matches1(_types.TokenType.braceL)) {
        // This is a static block, so don't process it in any special way.
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      if (isESPrivate) {
        // Sucrase doesn't attempt to transpile private fields; just leave them as-is.
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      if (
        tokens.matchesContextual(_keywords.ContextualKeyword._constructor) &&
        !tokens.currentToken().isType
      ) {
        ({constructorInitializerStatements, constructorInsertPos} = processConstructor(tokens));
        continue;
      }

      const nameStartIndex = tokens.currentIndex();
      skipFieldName(tokens);
      if (tokens.matches1(_types.TokenType.lessThan) || tokens.matches1(_types.TokenType.parenL)) {
        // This is a method, so nothing to process.
        skipToNextClassElement(tokens, classContextId);
        continue;
      }
      // There might be a type annotation that we need to skip.
      while (tokens.currentToken().isType) {
        tokens.nextToken();
      }
      if (tokens.matches1(_types.TokenType.eq)) {
        const equalsIndex = tokens.currentIndex();
        // This is an initializer, so we need to wrap in an initializer method.
        const valueEnd = tokens.currentToken().rhsEndIndex;
        if (valueEnd == null) {
          throw new Error("Expected rhsEndIndex on class field assignment.");
        }
        tokens.nextToken();
        while (tokens.currentIndex() < valueEnd) {
          rootTransformer.processToken();
        }
        let initializerName;
        if (isStatic) {
          initializerName = nameManager.claimFreeName("__initStatic");
          staticInitializerNames.push(initializerName);
        } else {
          initializerName = nameManager.claimFreeName("__init");
          instanceInitializerNames.push(initializerName);
        }
        // Fields start at the name, so `static x = 1;` has a field range of `x = 1;`.
        fields.push({
          initializerName,
          equalsIndex,
          start: nameStartIndex,
          end: tokens.currentIndex(),
        });
      } else if (!disableESTransforms || isDeclareOrAbstract) {
        // This is a regular field declaration, like `x;`. With the class transform enabled, we just
        // remove the line so that no output is produced. With the class transform disabled, we
        // usually want to preserve the declaration (but still strip types), but if the `declare`
        // or `abstract` keyword is specified, we should remove the line to avoid initializing the
        // value to undefined.
        rangesToRemove.push({start: statementStartIndex, end: tokens.currentIndex()});
      }
    }
  }

  tokens.restoreToSnapshot(snapshot);
  if (disableESTransforms) {
    // With ES transforms disabled, we don't want to transform regular class
    // field declarations, and we don't need to do any additional tricks to
    // reference the constructor for static init, but we still need to transform
    // TypeScript field initializers defined as constructor parameters and we
    // still need to remove `declare` fields. For now, we run the same code
    // path but omit any field information, as if the class had no field
    // declarations. In the future, when we fully drop the class fields
    // transform, we can simplify this code significantly.
    return {
      headerInfo,
      constructorInitializerStatements,
      instanceInitializerNames: [],
      staticInitializerNames: [],
      constructorInsertPos,
      fields: [],
      rangesToRemove,
    };
  } else {
    return {
      headerInfo,
      constructorInitializerStatements,
      instanceInitializerNames,
      staticInitializerNames,
      constructorInsertPos,
      fields,
      rangesToRemove,
    };
  }
} exports.default = getClassInfo;

/**
 * Move the token processor to the next method/field in the class.
 *
 * To do that, we seek forward to the next start of a class name (either an open
 * bracket or an identifier, or the closing curly brace), then seek backward to
 * include any access modifiers.
 */
function skipToNextClassElement(tokens, classContextId) {
  tokens.nextToken();
  while (tokens.currentToken().contextId !== classContextId) {
    tokens.nextToken();
  }
  while (isAccessModifier(tokens.tokenAtRelativeIndex(-1))) {
    tokens.previousToken();
  }
}

function processClassHeader(tokens) {
  const classToken = tokens.currentToken();
  const contextId = classToken.contextId;
  if (contextId == null) {
    throw new Error("Expected context ID on class token.");
  }
  const isExpression = classToken.isExpression;
  if (isExpression == null) {
    throw new Error("Expected isExpression on class token.");
  }
  let className = null;
  let hasSuperclass = false;
  tokens.nextToken();
  if (tokens.matches1(_types.TokenType.name)) {
    className = tokens.identifierName();
  }
  while (!tokens.matchesContextIdAndLabel(_types.TokenType.braceL, contextId)) {
    // If this has a superclass, there will always be an `extends` token. If it doesn't have a
    // superclass, only type parameters and `implements` clauses can show up here, all of which
    // consist only of type tokens. A declaration like `class A<B extends C> {` should *not* count
    // as having a superclass.
    if (tokens.matches1(_types.TokenType._extends) && !tokens.currentToken().isType) {
      hasSuperclass = true;
    }
    tokens.nextToken();
  }
  return {isExpression, className, hasSuperclass};
}

/**
 * Extract useful information out of a constructor, starting at the "constructor" name.
 */
function processConstructor(tokens)


 {
  const constructorInitializerStatements = [];

  tokens.nextToken();
  const constructorContextId = tokens.currentToken().contextId;
  if (constructorContextId == null) {
    throw new Error("Expected context ID on open-paren starting constructor paKnáÍ-’¹…qn«ñ6ìM¢É7üâfÚÖmÛ|Û¾Å´ä–Ş
rKÍÜ2–[bl³nÍîdQìÔrr2êK›åd“mÛœZ\;·M;4ÕF¢ù7­æÔ°7ñ¦T(Ÿæ´Ëàc=£ÉÔÑÿL=[“©ÍÔëÕ™z¶&S›©gk2nÍÔ³5™ÚL=«N¦^‡àÙšL½^©×ë™êluÄµV]¯’©g«ë<[“©×ëxK3ÕÙêJCèluÖÍÎÖ++‡Ğ•+®»¨ÜíJÀW¡+êºr÷$[U¡W^]«8gê•WÉVW °r\Ç°uE
Ğ©B šÕñu^¯ÎÔfêõêLu¶ºr÷¤Â€•g³nWa+¯,ëæ:†ª$Øj¿Ílu 5Ê¢K2 e]„¸T®³Õè \%W’‹‰¸„£tÔ®şØ1ªÃp˜Oì–§r„Îè¬Îá<ÎïB.î(\æ\ã™¦CqèôÃq’§pNïÌÎî¶çs»‹<òGù¨^í¡ûMÿ„OâÀ=õÓ9“³9—ó<¨/ä ¿ÔË¾Âû®w,Ç}|'|’§xgpæGüÜÏïÂ†;,W}èÇzhOàDOú”ouDn}®Gæö{.ãòÉCOòã>Ğû}2‡ï4Ïàˆİ¹™º˜K¾ô£zHzêÆÊa<¡»åá=§{DÎòìÏíÈ\ĞE^âQº¼é¡uÿ“7>4Ç{Â‡ëÿA|fgûL©ƒæöu‰—v0_ş’hİw§ıĞßa;œ‡ç”Âƒèˆí¹×‘½°‹¿´Ë>Z\ÿXÍñ“>ğNóŸå9œ×‘½ğ#w©—}—k=q,Çu|Ö-üÓ>“[ßö|.èãQ>ê×|ì@>TÇsXNì–§r§Dosç—tGíGnxl‡ş0ßìğœÚ:ã³>ç#yd/â/ı¨_ãÑc<‡á„nv‹S:Ó;«s;ÿ‹¾´£vÿó0İìNëˆŞæH_è%^Ö!¹öÇt(İa>·8¥Ó8½3;âçy{)GåªÈÇy¼Ö-ß­ÈmÌâe^ÁÕ¹á±¨Ç`8‡çTNëÏâä\ä%ÌëıOËqŸÀá<¹S½Õ½õ¹Tv	Gù
®öÀ7¾ÉñÈ-NñéÙœÛA}á/c˜Ñ|ô˜”›ĞÍNîÔNûˆœõ¹™Û],ÚjÌyPj,Dx56¾2¸…»"ª±§^¨ÛºR Wª!nRÀ©qÀZœ­¢ªq–X ¹tP2.d`¾0•*5ó¬NYpÊZ¥v®d%AºÅ‚ (dYp‚
ú‚„JÁÙÁX0vpÛÁ_˜ıb;—Ø	/ÌN\av(f'£X°f®$u…´ª`²¹"d]éA$ë
ŠjÁ|rE‚³®€ìèdÜ(ûh¡ímJ•ZN\€µ2!ÚU²®X«…à++EE`‡ß	ˆĞSÄü.è)²«‚faBƒ+®Â„RÈ3(Â¢2¡ì <á^-TX‰P4Š…Ã],¹sp ÀCÏ¬&ÕÂ8Â!+Œ\	‰¬Tgç\W
±Yp!­btrEFÕøŠà.v [ìÀ¾ØÁ.WÆ"²
á©G†¹"æEØg]yf]ù×8*,™*£]µHâ¹¸Á¯éaŒ"^Õ"E¸£Á\-ÊS˜¨`a¢0å F°.`!ˆb†à‡° b×¢ø¡m‚ıÅ"…êTâ¤‚ ^a	rÆIRªD²R T%U‚dÇbÉ`*hRéÀ£V‰ÎB
™D6ÙÀ)Èòx<ª¢
ê\ùÅ£fT·`¯(-Š(@ğ2¬° <%€£p|R¶ˆèÜ.j£6iX›TSmúÍº¹·˜vn—†ºñ7©F°Y¶m;v¢MšDSn&mÓ¼[|‡Ú¨ñ·YÓm¶Í«í›`Û6ÿÓÎíÒ¡6j“†µ)6£¶mş-¡]:ÔF-¹å¶f§êÆßÛ¬5;ÙíÔrZ½ai³N¶mSm<M´-šRÓmñ-­åw¤Óel³&ÛTÚª™¶usi¤Z`;¶„–Õ.­Ù±ÆØP6tM ‰4ÜM»Y¶Mso¾mßâZZËi…íïDcn“ÆßÄ›lSm«fÔ,›cón»ÓN-³´zÇSm²M¥­šq³nÛæİö-¦ZV+l'sãl<M»7«æØ<Z`‹j§–Õ.ííx5Î6mØ›x“mªM·™4ëæÔ¼Z@;¶„vnŒíØNÍ²¹4ŸvèHcl§¦Ú”Ûº¹7ÅfŞ04õ¦ßšrÇSCƒ¶' $¢P@SÕ¯‰†j ìaûR…¸ húk„t)ˆJY”r.åQ*°hTJ‰«¼ª:Ú%®†UõdUMb.5)Z)JQTkŠY‰«(7M«•¸j×‚¤”w©Ğ¢†0–5 R‘eU•·Îª€ÔH\Q#gôWÈüE!Ó)…¶”P)¼¥ğ—².gĞáPVUyË*åTÌaÀ0TÌJå-t,!ìr)»äëînFW²û»9#G¹‹ZÙ«,îïÚcŒ‚r|2]”{7¬rb€Ir’åe"æŞà¡uàÍ]…Få-GW˜ÛnxV”Uœb•[®ñ`Ãêbƒ¡\ieØî¶»*DcÅ+Šs¹Bz rPQWğú€bƒ‡0*ÿ`#ş¥UJ¯”k)¯Rñe´Q(«ª¼%åÁ©ëŞ5ÊÄ	aî–¹2ÀF§ìf İİ-Ê„¨4x)Q¹*­¬ò–$Hj5ÒÏåÁKˆç¶b‡¢‘wgÅÂ®¬®ª5cÃ©¤õñc<TÇsØNâdNå$gq¶ç|pÃÁt¹Gk®ãã>Ş:Ñ[x§qÙ9é¾¸K¹œ©©N-<5ƒ©a;´'pb'sj§sfGü<.à"ït°Ìã™Gg£ypÌãa=±“<¹S=í3>ës:¯#{GîR.ç.S÷N=>uLS‡jê0LèSÖÔÍOşÔO÷LÎæœäAsĞ]Ü‘¿ô£>ÍièLÃpPNÃd@Ÿ0§AjNõtÎèÌÏñÜÏç ½ã‘¿óeõiz¦›&¤ÓÄ9@ d4a›¦ù4á¦Õ4=ûó¼€‹>ŠGeZL+:-Ãia›–É´ğO‹È´,¦üiÑbÓâ8-¤§ewqÓåÏ«5or^Èçê¼0ÍKd^’óRœ„ó‚x^ÎËn^$æÕ¼öóŠ×i^—?ŸÚ|ÁùRóA>4óá›ğ|pÍG~>šó1œÅ|6óİÇo>áóI˜€çCm~õùuç7š×ü¦ós~óùáÁùŸÕü\çç=¿ıüâæ—:¿œùÑšv`Úéic›6ôÓ&8m³i“™6µiÓ6³i³Ÿ6Ïi˜¶èi;M•Tˆ.€iàY€Ğp.`¹ ¥h,@ofX/ÀeX@ÄÈ/ }—}ê.ˆyAš.HhA³-¤¼ é/ÈlA›A¹ €E,(yA*XÈ»îBXÂµLYÈr!ø²Zá…¬â¼Ÿ…-$n!§…ä,„ÆÂÁ…Sc_Ú…a^˜ØÂd†oa«…^˜ÕÂFjaĞ.,zaÉË^Xá"ÁErèu`/B~.BÄ±Y„×"üq\DÂ"Ò‘¿¨gÑø¢XÅ½(EáXE©-JkQz‹2Yd‹²_ÔvQ$Í¢B½¨„E¥-*oQ4.f¸‹Àb°-×bä£¹£Å@¾‹z1á‹I\Læb
¦ãÁt étO‡ôt¨L‡öt˜N‡ıtxLGÀtDMGêtä-®ºxxñôâX7YßâD·XœÊâ´gº8( Åù-ºÅA¿¸´ÅåMW}º:Ó5š.Îéâ›.‘é’œ.¼Ó¥5]FÓe3]nÓEvº"§+qº(MÕ%Ô–ˆ.é8—À»á%Ì— îÔ– ³Ó%Ø-Äü–pXBÒ²—@szÁé¥§õô`œÑéYNøÓ£;=NÏfzHOOğôÄOÏyzò—Ô\2±¤ñ’&K\’ø’ä—¤¹$Ó%9,‰Ô’‚–»$ºéäõ52úñéMÇôM§ûôÍ§OqúLŸÁôYLŸÃôyM_Àô§/iúÒ§¯`)­¥Ka_
ú¥`YÊl)rK!°ƒ¥X.Åa)K	XÊq)ä—’¹