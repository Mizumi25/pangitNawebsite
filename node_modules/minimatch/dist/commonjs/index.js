"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
const brace_expansion_1 = __importDefault(require("brace-expansion"));
const assert_valid_pattern_js_1 = require("./assert-valid-pattern.js");
const ast_js_1 = require("./ast.js");
const escape_js_1 = require("./escape.js");
const unescape_js_1 = require("./unescape.js");
const minimatch = (p, pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
exports.minimatch = minimatch;
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
exports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;
exports.minimatch.sep = exports.sep;
exports.GLOBSTAR = Symbol('globstar **');
exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
const filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);
exports.filter = filter;
exports.minimatch.filter = exports.filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return exports.minimatch;
    }
    const orig = exports.minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: exports.GLOBSTAR,
    });
};
exports.defaults = defaults;
exports.minimatch.defaults = exports.defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return (0, brace_expansion_1.default)(pattern);
};
exports.braceExpand = braceExpand;
exports.minimatch.braceExpand = exports.braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
exports.makeRe = makeRe;
exports.minimatch.makeRe = exports.makeRe;
const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
exports.match = match;
exports.minimatch.match = exports.match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== 'string')
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === '' &&
                    s[1] === '' &&
                    (s[2] === '?' || !globMagic.test(s[2])) &&
                    !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
                }
            }
            return s.map(ss => this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter(s => s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                const p = parts[dd - 1];
                if (p && p !== '.' && p !== '..' && p !== '**') {
                    didSomething = true;
                    parts.splice(dd - 1, 2);
                    dd -= 2;
                }
            }
        } while (didSomething);
        return parts.length === 0 ? [''] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
            for (let parts of globParts) {
                let gs = -1;
                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                    let gss = gs;
                    while (parts[gss + 1] === '**') {
                        // <pre>/**/**/<rest> -> <pre>/**/<rest>
                        gss++;
                    }
                    // eg, if gs is 2 and gss is 4, that means we have 3 **
                    // parts, and can remove 2 of them.
                    if (gss > gs) {
                        parts.splice(gs + 1, gss - gs);
                    }
                    let next = parts[gs + 1];
                    const p = parts[gs + 2];
                    const p2 = parts[gs + 3];
                    if (next !== '..')
                        continue;
                    if (!p ||
                        p === '.' ||
                        p === '..' ||
                        !p2 ||
                        p2 === '.' ||
                        p2 === '..') {
                        continue;
                    }
                    didSomething = true;
                    // edit parts in place, and push the new one
                    parts.splice(gs, 1);
                    const other = parts.slice(0);
                    other[gs] = '**';
                    globParts.push(other);
                    gs--;
                }
                // <pre>/<e>/<rest> -> <pre>/<rest>
                if (!this.preserveMultipleSlashes) {
                    for (let i = 1; i < parts.length - 1; i++) {
                        const p = parts[i];
                        // don't squeeze out UNC patterns
                        if (i === 1 && p === '' && parts[0] === '')
                            continue;
                        if (p === '.' || p === '') {
                            didSomething = true;
                            parts.splice(i, 1);
                            i--;
                        }
                    }
                    if (parts[0] === '.' &&
                        parts.length === 2 &&
                        (parts[1] === '.' || parts[1] === '')) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                // <pre>/<p>/../<rest> -> <pre>/<rest>
                let dd = 0;
                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                    const p = parts[dd - 1];
                    if (p && p !== '.' && p !== '..' && p !== '**') {
                        didSomething = true;
                        const needDot = dd === 1 && parts[dd + 1] === '**';
                        const splin = needDot ? ['.'] : [];
                        parts.splice(dd - 1, 2, ...splin);
                        if (parts.length === 0)
                            parts.push('');
                        dd -= 2;
                    }
                }
            }
        } while (didSomething);
        return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
            for (let j = i + 1; j < globParts.length; j++) {
                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                if (!matched)
                    continue;
                globParts[i] = matched;
                globParts[j] = [];
            }
        }
        return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = '';
        while (ai < a.length && bi < b.length) {
            if (a[ai] === b[bi]) {
                result.push(which === 'b' ? b[bi] : a[ai]);
                ai++;
                bi++;
            }
            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
                result.push(a[ai]);
                ai++;
            }
            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
                result.push(b[bi]);
                bi++;
            }
            else if (a[ai] === '*' &&
                b[bi] &&
                (this.options.dot || !b[bi].startsWith('.')) &&
                b[bi] !== '**') {
                if (which === 'b')
                    return false;
                which = 'a';
                result.push(a[ai]);
                ai++;
                bi++;
            }
            else if (b[bi] === '*' &&
                a[ai] &&
                (this.options.dot || !a[ai].startsWith('.')) &&
                a[ai] !== '**') {
                if (which === 'a')
                    return false;
                which = 'b';
                result.push(b[bi]);
                ai++;
                bi++;
            }
            else {
                return false;
            }
        }
        // if we fall out of the loop, it means they two are identical
        // as long as their lengths match
        return a.length === b.length && result;
    }
    parseNegate() {
        if (this.nonegate)
            return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset)
            this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        // UNC paths like //?/X:/... can match X:/... and vice versa
        // Drive letters in absolute drive or unc paths are always compared
        // case-insensitively.
        if (this.isWindows) {
            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
            const fileUNC = !fileDrive &&
                file[0] === '' &&
                file[1] === '' &&
                file[2] === '?' &&
                /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC = !patternDrive &&
                pattern[0] === '' &&
                pattern[1] === '' &&
                pattern[2] === '?' &&
                typeof pattern[3] === 'string' &&
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === 'number' && typeof pdi === 'number') {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    }
                    else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // dont' need to do the second phase, because it's only one string[]
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug('matchOne', this, { file, pattern });
        this.debug('matchOne', file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug('matchOne loop');
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */
            if (p === false) {
                return false;
            }
            /* c8 ignore stop */
            if (p === exports.GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug('** at the end');
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for (; fi < fl; fi++) {
                        if (file[fi] === '.' ||
                            file[fi] === '..' ||
                            (!options.dot && file[fi].charAt(0) === '.'))
                            return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug('globstar found match!', fr, fl, swallowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return (0, exports.braceExpand)(this.pattern, this.options);
    }
    parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return exports.GLOBSTAR;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
          RÑÖÔÁ	M£¥-¿½¥¥î0ìhÇ­(¥ÛJáa”¸ãÚ¤
¸÷§\ô¥ÌW-È1Í.3VöGƒ4y1xçÓ¹ÇìÙS {UÃ8ûÍšaŠ<}ãíÅâtÙ[QRì\ıê_'?ÄáUÌ‰ädŞ§òT?…<C±ÏÖt5M²?*Z²ğÆÚÔÁç©Ç­>dÁÓh®zÓjú[ÂÇ˜aš´šm«c!\Tºª%G9lbíàPWŠèF“hËÁ`}I¨ßG·şû•‰‹4ú•NèÀÛÍOáZwÆNİÄ™ªŒƒÒ¶ŒÔyÑqÜ¯·ŠMµ6ÏZnßÂ®æ|¤ei1Ï¥K¶Ÿ;ŠÄEqIO½M°şÒŸ¥4ÄÕˆñÁâ“ CNòè¹6"Ç˜©¼¾”›jwSÒ±IŠ}ñœçĞXf(Å:ŒSçQ˜£üRQí”n)1O¤ÅĞ9FbŒS±F(ç(ÜRbE>påŠLSé(çA¸¤Å?˜£Ú ÜRbŸŠLQÎƒqF)Ø£s‡ ÚJv(Å>päŠ)Ø¤Ç±£œ9¢—ğ¤§Ì¢(Í§Ì.P¤£šJwE&h¢áa8õ¤£šwƒŠ^)9£šwáKŸaM¥æ˜X3Fh¢‹ŠÁš(Å&)ÜV4f“š9§p°´RsIEÀZ)9ÏZ9¦KIE ¢Š1Nà%QEÄ%´b‹€©;S±F)Üştb—˜¢à”¸¤Å2=h£miÜŒRmúÒ…Å”b”Š6ûÓ¸£»iqÏ½¸¢¶—h¥pÒŠvÚ6Qq‘ÒT»(òù£˜,CG?•G•G0Xˆ ip)ş]/—G0Xhô¤Ú*]†“gµÁb=´b¤ÙI·Ú•ÂÃ1F*MÔl>”ù‚Äx£&ÃéFÏj9‚Ä{sFÑéOÛF(æì>‚§Ò¤Å.(æygÚ—Ë5.(ÅÂ±”i6SâŒSæR´›YÀ£s‡)_a£aô«hÛG0r•qÍ«;2sHÑƒÔs‡)_ŠJ˜Æ éL)MHV#¤§â“m;ŠÃ1E;miÜ,6ŒS¶šLb‹…†ÒbŠLQqXLQÖŒQNà¢ŒÑJá`£š(¢á`¢’ƒEÀ)sM¢€Óii(¸'JZLS¸	G4¸£\VÒn>´´b‹Œ7PM.?:W ëH)h¢à¡hü)Àãµ&ÇaÁ?¥=ƒ•céƒŠb¹©âaüMƒéŠ‰;‘û¸ IíVw€x*síL7İ^=ª9ÛÙÊˆÁ˜t'ğ¦³IÜ“Ÿj“í2g¨Ç¦*33óó}¨WìCqwô¨ŒlAÌ`}EN³:ç¡>ã4¿i“?Â
«Ë°Yöm'åúf›·Ú®ı ç”SõÆ“qûª>‚š›ì«¹Saô4y'`·û"šXú
®fO*+ı˜ú‘øRı›ı®*RIîE6«™ŠÈ…¡ÁëM1ZœŒÓvÕ)	ÄƒÊ´W½NV›¶Ÿ1<¤>W½7Ë÷«qMÅR¹H|±ïM(j|sÒ“\Âhƒe*}´˜§ÌO)J6TØÅSæ)_e*|
L{SæˆvM†§Å7Ó¸¬DRŸKj1Nâ±Ïz6{Ô¸£Ó¸¬E³Ş¦¤Åâ‹…ˆöÒm©1F)Ü,G²“o¥K¶ŒQp±ÃFÎjJ1Nâ±ÃFÎ*LRbŸ0Xm.Ú~)1š9…a˜£üRbÂÃvÒc&)1š.ƒøÑŠò¢Åa˜¥¥£î´¸¤ïJá`¢–ŒQp¥¢Š`%½¨íEÀJ)i;S:ÑKF3EÄ%'zv9õ¤Ç4î+	E.(Å;…†ÒŠ\Qh¸XOåE;w¢áa)Ô˜¥ ½.}é)E ¸àx¥&›œRgš,W0¹ç¹£&“4™¦&Å}©sMÎ~”n§¸“[ñ4›¹êi( wu¦ÒS°s2A!*^}*¶hõ¤â˜ÕF¶.h0úĞoÜ÷5Kµ½œJu§ÜšIË“Ï59¦ÑœÕ¥c76÷
AKßŞuª3nâ:S±IŠbi?˜¢àÆdƒFãô§b¿…2l&sE.?<Rw¦#Ñè¤¢¾&çÑX\ÑšmÂÂäÒn4R~4MÏI¹©ß'ãUt1»›½ıêN}i9ö§Ì€{ÒyşEKÏ ¤çÚŸ2ì#ó_Ûò£ÍoAO9ôœú-;Ç°XoœOaGœiØÿ ei1şÊşt½ŞÀ7Íoj<Öôí£Ğ~tl_îş´ïÁasz
_8úS¼µô?ZûÒ¼;˜Ï?Ú“Î4óûÑåSM8£|ÓHe>¤~4ï'Ş“É÷§x¢o÷9úÒy¼Òù<u¤òG­4â&˜ß<úGŸşÏëJa÷¤0ûŠ»ÀVaçÿ ³úÑçîş´ß'ÜQäÿ ´)û‚³çîš<åô5•şĞ¤òıÅ4¢-I|åô4yÃĞÔ^Yõy~â¢’yãÓõ¤óÇ÷Zg½QõÒˆµ%óÇ¡£Ï_CQˆO¨üèò[Ô~tZ"Ô“íèhûBÿ uª/%½/’ŞÔíÔÚ÷M/Ú¡¨Ì-Hc#½ˆµ$óÇ¡£Ï†¢Ùî)6švˆjKöıÓGÚ÷ME°ã¥&ÓNÑ¤¦ãıŸÖ”N;‚*R`Ó²Kzú<õô5_—iô4Z"ÔŸÏ_Ê9=ÿ *¯°ú6ŸCG,G©cÏOÊ91×ôªûO¥M¨Z–Ëê)|Ôşğª»M&>T—<Äõ×ûÀU<0M.D.ï_ï/ç@`‰:¥Í>”r ¹{ñ™úU>}é~ophåó–³´™ªùSùÒîÎP¹7zZƒtô»äjNj=ÒúÊÒcîŸÊ‹ ÿ ŸÔ~T|şÕi=ÇáFù3Ş˜‰²Ô¹>•‘³Êçô§y‡û¦¥¡Í.j=çû¦çû¦‹“4¹¨÷îšp9ìEKù£9¦ä{şTfÇfŒÓi7qÇ4‡æ–¡ŞßäP½?JvjZ‡yî¦3ØÑfÔµš=(óE+0&Í/‚¡ó­gãE˜|¿İ£äşíCæûP&ö¢Ì.M„şí.Ò ó½©¾qö§ÊÂå«éI°U9½hó[ûÔr°æ,l_Ò ó[z—ÍoZ9X]l¤ÛQùÇÚ;Ö‹0º$ÛIŠo›š_0{Q¨\\Rb—wÒ“w½ ¶šÉRfšMP¤ÙRšJwˆ¶Q²¥âŠ."ÙíK¶¤¢`±	šR§Å4i©
Ä;}©6JŸ˜£˜,C³Ú“oµO¶´sˆÑ²¦Ú)v
9‚Ä)6ÔÛ)6QÌ"ÛI¶¦ÙI·š|Â±Z6T¸¤ÅÁb-”m©qF(æR-´m©qIŠ9‚Ä{hÛRbŒQÌ#Å©1F)sˆñF*LRbÂÃ1F)ø£®Ò–—b‹ŒLÑ“N¢•Æ7&ŠSF())Øö¤Çµ´Ÿ…?Ô˜¢à0Ò~Ú6æÀŒÒtì?*—e}©ÜV!Ï°£>Ãò©vJM‚‹ ³#'=…7§j›`ô¦”ÓˆóáÍ&Ùı”lâªèZ‘~’¥ÙI²©1X„óF*M†“eUÉ°Ãô•0jm”›)©	¢{PV¦ÙI³ù…ÊC¶“ozœ¥&Î)ó”‡Ô›j}”ytùƒ”ƒm&ŞjÆÎ:Rlç¥Âå ÛÅj}”]5 å ÛF*Ç—IåÓæ)_b¬y|t¤òùéO˜9H6Òm«]'•ÍÂå ÛFÚœGÏJ_*`åem¦Ÿ­Xò©\û
|ÁÊWÛŠMµgË¤òéóÊAŠMµ?—IåóO˜9HJĞV¦òÿ *6qG0rlô¤ÅO³š6qÒŸ0¹HvÑŠ›Ë£ËÇó£˜,AŠ\T»=¨ÙÇÖŸ0X‹mxş•6ßÊ“gZ\Áb~tm©ŠóÓò¤ÛùSæˆ¶ûQ¶¥ÚivÑÌ;â¾Õ.ÚM¦Ÿ0¬G¶¼ô©vŠ1G0X‹oµ&Ú—baXg›j\Q¶Ÿ0ìE·Š1Ríâ—osˆ±IƒRím§Ì.R,QŠ—o4m§Ì¤x¤ÇåRí¤ÛùÑÌ.R=¼QŠ“mE>`å"Åj]¼Òm§Ì¤xö£oåRm£QqX›y©1F)Ü,G¶´üQŠw&Äxæ—ì`ÒãŠw†möâ“mIGZ.+â”/ò2)1NáÊ7m§b–‹‹”fßÆ—m?b‹Ä{(ÙRQ×µ;‹”nM&Ú“ÔS¸šG}E74f¾*ç½ah¤Í¢ã’“4f‹€¦’ŒÒf•ÀZ8¤¢‹ŒZJLÑšm……¢“4f‹€QIFh¸ÃŠ0(Í%h¤Í¢ã’ŒÑš.E¤Í;……¢“4f‹€b“o½.h§Ìe'—ïNÍ§ÎÂÃvRyJ~hÍR›òş”ytüÑO‹”g–)<¡RfŠ=£R?,{ÑåCRRfŸ´båå¯¥ÒŸE>v£6J1íN¢påÿ ¤Ïµ?4”s)î~è¤Ïû"¥¤ÅW9<¤yÿ d~Tnö•Ij0=)ó‡)ÿ aH[ØT»G £hÏAT¦…ÊBOµ%O´z
MƒÒŸ:RRb¬l”›¥5P\…zJ³°zRybŸ´Bäd÷£ïúTŞX4X§ír20~‡ğ¥Èô_Ê¤òé<º9Ğr±™úRw©<ºO/Şt.VGøPõŸ°úÒí8ëOœ9Fl´l\}ìSöóÒ“o¨¹ƒ”nÁıê6µNÚ=}¨æQ¾_ûT_ûTí´mù…Ê7Êÿ hQåïqNéFMÌ9Dò÷¨òÛûÔ»(æaÊûß&Çş÷ëA$ö¤ü(¸XvÖş÷4c?ÇÍ7v;Rï>”jö©FëúSw]ÇhÈÏ\ş‡nxÈ¦gŞŒûÒ'ş*7Œuı*=Üu£4ì!Å¦“ïIÅuíM3ïGãG¿/½;…„çÖ“šv=ø£o½†óG4ı¾ô˜Çz.ip}©1Nâ°~søÑŠ1EÂÁÍÑF(¸-%/µ)y¢Š.“ëG4dzRäzR);Ó¸¤?Z.sKƒE.ïjM.Ö£µıªnÇ`ØŞ´l>´¾`¤ó+°²i¥Ç½!qI¿ß]€¸Å.)›½èİïE€v)j=Şôf€IÒ™š3LëIŠ3Fh¸£m&hÜhÔÚi6Ñº“>ôj1vÒm£4™ Bâ“Š3Fh Å£4S¸	ER¸(Å”îâ))sHŠ)3IœP1ôf™š3@¦÷¢Š@¢“4”ÀZ)(Ï Qšm5¤E?3 ~´À“µ6 ’åpwAUšêCĞôJ,–Ëù¤ÍQûT€v'Ôö¨^Wpw1#ëT¢ÅÌ_kˆÔà°Ï·4õuqò°#Ú²±J¥åXƒìj¹Iæ5;ÑÅQK·_½óÖ¥[Å#£JÌwEš8ªâê2:~”áqş!øñKQİqIÅ7x#¨#Ö˜×©å×?Z —Ò“Ò¢ûLCşZ/çM7ãéÍ=BèŸŒJ©ı¡‹J?´"ÿ kò§¨®‹X”cÚ«øI·åN°wãê1OPº'¤Ç5ÚáÏúÁHo!?AEØhMŠ1š¬oğ®OlšO¶6>êştõ…¬QTşÖç²Š>ÖßİZz…ÑsÖ›Uã~UÖ“íRg¨?…=Iº.`QŠª/¸ô£ílGİZ5¢Ö)1U~ÔŞƒò¤û[ÿ ³¥†…¼qF8ªŸkA¦i~Ößİõ¢Î)0*¸º8û Ğ.½W­bĞ³¶“gåPı©ºhûZãîiİ†„¥*/´CGÚG¡É¢ìVD›hÛíQ‹”ÏqKö„şöM;°°í¹£m7ÎBqNŞ¤}áNá`ÛíI´RïSüCÓ­.G¨?.`å·ğ£üQü©ó”f8¤ÚI}©)ó†m£oşÔcÖar‘â“o¤Ç”bŸ0¹Fm¤ÛíO¦’p)Ü,&ßZ6Ó|ÔÎ9?…8:ı{QqX6ûRbĞu¤Ü¿ŞîŠZkÌ‹ß'ĞS>Ğ;/æiÜV$ïíGj¥rzãéHf~çJ`OÚŒQùÕBÙ<œšNıiˆ´]¼?:)<«Ç­'ëùP˜8õ¢¨çÜÒï8ûÇóªwcGw¹üéwÌ: »IŠ¨&uş#øóO$Çğ§q1IŠ‡í<t¯jiƒ&¤¨~ÓşÍ'Ú÷iˆŸ(ÇZ€\ó÷i~ÓÏİ§qcT?içîÑö¥ÃúÑp&ÛFCö‘éIöŒ˜¦‚ÄôUs1#ü)¾g¿ëL8£Š­çQæŸZ©kQIÇÒ«oô£Ìø©Šå‚@î)»××¥AçqÍ'íŠ.#Ñ(¤Í¯Œ=ái3E€3Iš(¦E¤¤1hÍ%%0ŒÒQ@ÂŠ( 4QI@IE)3KE &hÍS £4RP1sFi( Í¤¤¦Òæ“4SsIE QE%0šJ3IL¥Í% fŒÒQLÍ¤Í Í¤Í¦ESQšJ(š)):Sš3Iš(…Í¤Í&i…‡Ru¤Í ,.hÍ74gšwÍ¦æŒĞ+ŞŠnhÏ‡QMÍ§p°´¼SsIšaÔSsG4îÅ%&hÍE&hÍ;ŠÂÑŠnhÍaqF)3Fi……Å¤Í¢â°¸£oµ7u.ïz.¢¢ŒÑšwaa6Š6Š\ÒgŞ‹ŠÈ6J6ûQš3Nâå¢´gŞŒÓæÚ6Ñš3ïEÅa1Kz3FiÜ,&)qïIškÊ±©g`ª:’p‡QŠ¨º¥›¾Å¸Œ·×ŠpÔ-QÏr2 5V}‰Ğ³EP}bÍ	ÌÀp@¦ÿ mÙqûÓÿ |šj2ì+®æ…“>¿oR´„ŒúUˆßş}Ôsİª”$úš(ßÍ&k ø‰ÿ çİqÛæª³ê÷3‘‡1€rSTä.tu=(Írª]·ü·aô¦E¨]DNÙ›c“ŸçOÙ1s£®Íâ¹6Ô®ØÓ8Úx#Šrkˆ?×?Ú£Ù0çGSš3\¿ö­Û¶|ü=0A5ÅÃd•˜õô¥ìØs\·1À›¥uEé’qTäÖíQNÖg# ­so+¸™›œâ›¾­R]IuĞ?ˆ!m‰ØwÉÆ*×ä9òâP1Üæ±·~T™ªT¢.vloOÁòĞõ ñÏÿ }V*šÖgæfêkË»÷‘=TäŠ•uËs÷–E÷#"¹Ş êsK¼qÛ>Í:Í¼U‹Gè[¡§¾«j‹‘&ãØÍsd‚i¤àô"—³Cçfók‘dmˆ÷8§Ç­[°;Ã!ˆÎkƒÚ”É8§ìĞ¹ÙÒ¦©jã>f=ˆÁ¤şÕµÚNóÇl`šæÃûÒîãŞ—³CçgOı¼‰¹eP1’	ÁÁª[Ûæ~8â¹Ïóšy7wèj}š3:••|¬¤{Òî®UeÌ<â¬-ôˆ1Ä˜Ï†j\
æ:-Ô›Á8Ü	ôÏ5ÍÉq$„îÎzv¨GWqt9¦¡q9^ê7P~•Î›‹ş°Ÿ`qQŸ62Ëx¥Éæ;6ğI#¨Ï"àu }MrûœËÇ^†›¼ó’r}éû1s—ğFd094ÕÔíÊä±ÄV9¥ìÏBHÀÈéG sƒT·$üÌ0{´6©n!‰>€sXHëƒ¾”æ	µXz’sš9avmjÛàrÙ=±Q¶±~Tcõ8¬‘åàeiÎ‘ò¹'¸Åˆõ5_R&2ÑÄçŒäô¬Ùg’bK3lÓ"”/#O=§€YTƒÔàÒZ0jëAŠì¸!ØèjÔw÷€KoR8İÍW0HÀÈqJ!Ÿäb=1TÜ_Q(¾Æ¬¤2Ÿ÷mïÈ5/Û­óşµIéX/‘æ+&y 9ÏÅK‚{ínlÍ©GFñßjíŸ–!Œ÷5¸í ƒŒõÇı)¨ lÑ«äe•'öªãıSìk-dù¹9Qíš³\êUT½ ©—,ucŠrØML°ùT¯óªÿ jó»êi$òÉÀbAêOZfô.ĞG©)©.ˆ|É|å8ù…#\(dšULäm ö¨˜ú*à½ÅRw%¦‰¾Ñœ|½hóºüµ¬l:°onE'<yî+	‰Ï•4ÈÄıêhBÀpH'­#FT÷;w‡#·$t£-“œ¥>wj’AìqO;?X`üÇ5.vv)Bêä] Á>ø¥ËvÎhc~]À™4o+‚§4îÅd!wÉœ}hV##šVs)Ë7$ó)|‚äœ8d·WĞnîiZ5 2œf”!'”{“Šq‹(zà÷ô£˜9H¶àuÉ¦d“€2{zÕƒchRF33L]±òœrj”Äá¨ÖLÏ#®;Rv÷©ZU~Š>é€HPsß4)>¢itô ƒŸ_¥Z6ÁîuĞ!åI¦÷"g¸ÉÁÁö¬İh¥rÕ&ô)¨ |Ù¶iÌ×±éÏ4æ*ÊKNi>u??İÇ^â¯šäòØB@šÍÓ8N3F[iÆà¸ã#ŠO¹şñ÷§p°à7†F1Nÿ MW?N)Èù´˜ à 2)%`îNr:gÍ.fô+•Xp„÷² §­±`pÜ“Æx¨Xãi` â¦ódP+Ø‘ŒÔ¹>ŒqQê†I	;ø ã=©›	ÆÒÄàqR£³ZìzÒ§G”)ÆèqG;CäL¥±ùÈ É¥ÚG~=êáO,.G+Õ¿wÒ£•„„.'¸Å%VâöIì3¸œ`SBÿ ysŞµ7“ğ9ã®EDY„„Ó5JW%ÆÃGA'¹=)ÈœÇ#8¥l»‚iR	 ÎŞHÉsMÈ#a~RsÓ¤„)8İ€zñœÓ^,°H?LRíqÆ2G^hnëpJÏaí
à–e¶)éº1Ææ"«A­5‡p)Y¾£½Äì‘òU£õ§¼ÄLGSµX)Èã8¥	Çµ;y…ü‰
ìÿ dõàäS~Ğˆd\zŠ@£¶:óÅW±­R}Å¯BQ8?tãØšcJùù˜€xt¨[i1ïJ¡×¡8=RV&÷$óyá˜{š<Æ'ˆ>µ,PùŠKDÃSd¶e'ËIÇzu{ÈípI£S‰YÏ¸lR¼°ìù%pİ9Í1­S2ó‚r*‡ËÃ}Õ·Mt&#•Ô·±Í++ŒosŸ¯#En¹ÉÉ¤ùsüYì:æŸ0rÉ üæ“#x’;b¥ò[²“ê3ÍŒ4Lvqr¼9ëOÛşŞ>¢¤GPGî‰ ğAÆ(–6.mU=1G>£äĞƒíô¦t'œŸZ³k“¤¼ÒˆÄ‡	nİ:ôı¥ƒÙÜ«×éK°×Ÿ¥Zò•@,„p8ÄzÉ^¥‡§íEìŠ{¡#Ö›¶­¯”¤˜ı{RíÎ2£¹8£Ú²)l9£ËüjúÃò®G$À£ìÛÆèòÔô£Û ö%/$àt”ÄåÔ}9«FØ’~`y¦›SıåÏ§¥ÓÌ=“ìT(3×?…ãV¾ÈïŒ $ñOû ÉÉ=‡8§íWq{'Ø¥åZzZ;®TqêjùÒÈPVEÉè¦-¤ªãæQÛ9éKÛ®Œ¥A­ÑPZ¶îA&”[rw zUÙ-ä@7Ë’{)äSZ V+éÚ’«æÅv(v 8æ™åñÔV‘·@>fÏ°9­lƒj‚FIÎH«U…ìĞƒ½.Ü:U¿°³Œ‚ú“ŠŒÛã$ØªUêC¤×B¾ÜšQ$s€{Õ„µf'8ÇÖ¥û4y!˜;š=¢I•8ÇİlÔ&>}ªúÃ1 ôÖ…sòc´Õ@tŠkæÆ2iŞCóò¶§J“Ëù¸9©F@ÿ ëÓö„¨Ùq‘ÜRl«~^ó…ğ§Ãa,Äùh\x9¦ê¤µaì›z6u¤ÅhÉ§LŒAŒ‚qš‰-Xœm$w"šªŸQ:RìSÎ—fOµ[òÜÏÔfœ ¸É>S`ú
~Ô^Éö*y u>†œ#ôgì÷÷b|»Aµœ20cĞmæ§Ú.å{7ØíóEù› QšJ(°šJ)3E€\ÒQI½