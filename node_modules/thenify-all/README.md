register(c0);
uniform float3x3 _umatrix_S1_c0_c0_c1 : register(c1);
#ifdef ANGLE_ENABLE_LOOP_FLATTEN
#define LOOP [loop]
#define FLATTEN [flatten]
#else
#define LOOP
#define FLATTEN
#endif

#define ATOMIC_COUNTER_ARRAY_STRIDE 4

// Attributes
static float4 _radii_selector = {0, 0, 0, 0};
static float4 _corner_and_radius_outsets = {0, 0, 0, 0};
static float4 _aa_bloat_and_coverage = {0, 0, 0, 0};
static float4 _radii_x = {0, 0, 0, 0};
static float4 _radii_y = {0, 0, 0, 0};
static float4 _skew = {0, 0, 0, 0};
static float4 _translate_and_localrotate = {0, 0, 0, 0};
static float4 _localrect = {0, 0, 0, 0};
static float4 _color = {0, 0, 0, 0};

static float4 gl_Position = float4(0, 0, 0, 0);

// Varyings
static noperspective float4 _vcolor_S0 = {0, 0, 0, 0};
static noperspective float2 _varccoord_S0 = {0, 0};
static noperspective float2 _vTransformedCoords_7_S0 = {0, 0};

cbuffer DriverConstants : register(b1)
{
    float4 dx_ViewAdjust : packoffset(c1);
    float2 dx_ViewCoords : packoffset(c2);
    float2 dx_ViewScale  : packoffset(c3);
    float clipControlOrigin : packoffset(c3.w);
    float clipControlZeroToOne : packoffset(c4);
};

@@ VERTEX ATTRIBUTES @@

VS_OUTPUT generateOutput(VS_INPUT input)
{
    VS_OUTPUT output;
    output.gl_Position = gl_Position;
    output.dx_Position.x = gl_Position.x;
    output.dx_Position.y = clipControlOrigin * gl_Position.y;
    if (clipControlZeroToOne)
    {
        output.dx_Position.z = gl_Position.z;
    } else {
        output.dx_Position.z = (gl_Position.z + gl_Position.w) * 0.5;
    }
    output.dx_Position.w = gl_Position.w;
    output.gl_FragCoord = gl_Position;
    output.v0 = _vcolor_S0;
    output.v1 = _varccoord_S0;
    output.v2 = _vTransformedCoords_7_S0;

    return output;
}

VS_OUTPUT main(VS_INPUT input){
    initAttributes(input);

(_vcolor_S0 = _color);
float _aa_bloat_multiplier5640 = {1.0};
float2 _corner5641 = _corner_and_radius_outsets.xy;
float2 _radius_outset5642 = _corner_and_radius_outsets.zw;
float2 _aa_bloat_direction5643 = _aa_bloat_and_coverage.xy;
float _is_linear_coverage5644 = _aa_bloat_and_coverage.w;
float2 _pixellength5645 = rsqrt(vec2_ctor(dot(_skew.xz, _skew.xz), dot(_skew.yw, _skew.yw)));
float4 _normalized_axis_dirs5646 = (_skew * _pixellength5645.xyxy);
float2 _axiswidths5647 = (abs(_normalized_axis_dirs5646.xy) + abs(_normalized_axis_dirs5646.zw));
float2 _aa_bloatradius5648 = ((_axiswidths5647 * _pixellength5645) * 0.5);
float4 _radii_and_neighbors5649 = mul(_radii_selector, transpose(m