'use strict';

var cst = require('./cst.js');

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = '0123456789ABCDEFabcdef'.split('');
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split('');
const invalidFlowScalarChars = ',[]{}'.split('');
const invalidAnchorChars = ' ,[]{}\n\r\t'.split('');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === cst.BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            const cs = line.indexOf('#');
            if (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd = cs - 1;
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if (s === '---' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return 'doc';
            }
            else if (s === '...' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                return 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            }
            else {
                sp = 0;
            }
            sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield cst.FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yiïÿşï¿şû¿ÿûïÿşï¿şû¿ÿûïÿşÿ0š( *°*0äcÓÆe"7O~LêŞ«)¶×˜[ğµß×ı÷ÿ!2²|ør]5N"+YÂöf;“Ë9`BĞ¸ÓˆAÆNÌ×üÌbÒ™tB)ìf8,<Ã}Ñîİ¦mCÓ' ¨˜RµXC3ª.a˜½),yBªZèfq‚uËkÌûea¬„—Å¦"°ÔYÏÏ¶ìC´hËyüI5X¦ì	ô„ÕEñ¤_æßèy‰mì4ëhƒÚ£¯^ÓPQÌ˜-[’ë”E«ïµb¹°KvvöT±ÅS;ŒëÕÑÏV¬÷›Ö©=\+Ìû“fD8 p8\mKc~'™›/°Ïï©œA
l›nÖ”dº-T€µ'¬ñãRQñAiyÖI%ÿyK’·ÒÅ¬ÄÉGÊÊÊ½ø.NøğÚ‘ÁÅ`Á}ñ|aÒ÷c©cSqÜcF…ëìı3p®vÇò‚/]×^X£fù¾Ç-OÚ<O€½È=›éˆÊ$,x€ÍúWÃÚmhÒ–¨DYøÿeK†¹¡7\ÖèßãË×œÏa^2ŠP‡Í‚¬»`Hä9Êá5&˜½ÙYÔÑcå…Ã®]9Û”­ÿ±4ñÃuŸp_Nk¦2ûhx[ü×õK[FXµ%æß[º]§ã£^~ŸWÃ°àD=ıÛp|õ²•|0]Ú‹óí³é0¼ŠZVhéïjGŠ~^rºŒú¨g&kRé«Û–psy7AMÛÓu[ƒ–J ¡]5Ø©eºˆœ1•¡gtnige7|,™,#8P%hÖ
ÑU¢æ ”P²K±:Eè7H…È
Êú°fY
Z§ÈÏa¨ •…ACqƒ;hĞ6õ£vAš'
%>¯>%¦›òÊ!³Q9~›vºGGÆÓ$™åA©²Uh"UñöàD×Íèg,ŠÑ®şv8ï>¨†|‹…èêEôİAe£–Ö2Eº#´HŒ1+T?õè‘}t|Ñßiü‘U·¾»/Q²DQ>$rò»øFû„ìôƒ¨wzœñ:Üeq>MÇ‹¡7"0(¨_§Ó6ñ”6¥‹L	ˆXì(‰.›Gz/dïPä° L–~R2¸wVéÚ%|X¢3´F«§Á/ÿ/ á”a¡Ã½ òìÒ÷ÛNZ.YV†!7!%iê9’’{:]¾B¨o1ö®¡sÌø·`0òa(&„t–Ş•wc÷]¬ã&(dó<±{„·›Ç”®Y}õG€„IÈ{£¢–?8	ÕãfÉâ7If;ò~/PCõæ€ZYúRiË‡Ç3ÿ>$ÄÖ¸NÜiiİ[æ *îKa¼y.ââ>“[¾ÆÓ]îúñmò÷\–ÜøÕE±—ùÀæ¹ğpÌ>Ú=Ÿ‹a:oõÑ!ª|åºñ›µ]hŒ-Á_ûÌTRÙÉùâÅøHåX÷Ö“k´ü×mæÚİÏ&°n:shF"Øªõ\¨@„,˜[†€,oƒ¬
Y 9M¡‹6tF=¯õØ6ÊñyÄC×gÓàIØ©â@Çê9¶xéxŠğO¨´Qt’<iÑ¨ìˆŒœŸ dJó³1H¹÷´]àà€¦)Ÿïº¥¤‹„)ú¡›%ô1k†’mÊ­+pÜõR¹N)o‘ğèGÂªÍÄmIÉÄÆrá&Ø¾Ú¹´T.[gºÔ¥#=f^“ô“·âYuH:øğNN .ºPú6©:vm0‡Ì`š/Q;¡ğ¯e¸È) »§ÂBÂ»¨m†‚ÀEnÃùùüZòšêzj¤Ôyù•¨wÅM¾hÜQs®v,º‡Ùå´E×úŠ{!1ÜãöÌ¡²ğch¹ÿL³%ğ«—]õŒ½qkhù¼BLGÂ¤œ‹±ü6O	¾çıHŸÍ}'ÍW2t€ò%Œ˜AË;ó*ˆÇ»“Ír%mC—^¥şòhq˜¹%VÚµïovU6ôZ­[èİ—¬t2MK*¯ˆŠè<Ë]”ñ()mC8’*V”§2ëEI‡#b›ëî¯„(›ûó©–Ökª1ş;w{U=ıQÍ`ó§şß€Cî†7¯ßº•î¹`!õÌs†÷nü{CšuVÉaéB€íä"N¼Êw*Hf~Aƒ8Òú¡©Qìœ#“š"ÄË)”d€§9‡òÎ¦R`ÌHõ‹Øø
ĞT’¡ËO³½ÿ…Ûªæ¹¾‚PAj$d¡(S¥@XR.W¶t¤ ù2pšZûªm48î!ûÄŸT–­Æj‰z9‘o¯/Î(w³ƒ9çtmjËY‰•‰èŠe<:w^ÓÏÇ˜ÛG‘ì‡ \Ô6Ï¼È¸…×Â-TÙ³§wÕ']j!HsìS6Ú¯7OkÚ®¶Á¯Å•p/ÁÙ¦/qû›<¥M<fØœÉ„¦ŸEÅËJîÁ¾©[+ÂÇ$¸B=5Ì{2ğÓƒê†O5Û5 Ş5¿É¯¶(’ôë—CúÆØA©ÂwìàK­^$Ä6aş‰w?é4ICàO ğ\’`rZÃ Ìf)ÜùS@¢8ø_¹L¶*Ãï34“Ñ¶rÛñúyÂ±ó~åbŒäOA“'˜fÆÇ§ÏT¢_&|  6s³ÑXØí/gĞŒÄÑ§üÂvàQ¾ŠÁ;òùò®¼G}TXz@í oĞ‹ÍŸì3GşœQsr·ƒUZßí'9¦clGİß…İ>;q2Qâ¤£•PRÛÎ/ß!÷†()Âˆ§;ì$úÛX™ÛaŸ=Çæ3õò»ÜlŒ€û¢_KÛ½U_Ÿ»¡é¿-=êÕıº›n7÷ëÊ·ŸVŠ3ñ:÷Xº—³4ÏsÎÂ­ú·›ßœÏ×›ã¤”ÔÉU®onæ*@Áİ"ee.}øÀuö|H){7d±	6ÖJç@×}¤åŠšüõà«´BÂ[¹Ÿ2.°:‘Y(!5ä²,…½¦f†,ô°Qsõ8¹’U:§Oç4÷Õ‡Ç²ÌD¬’=šøğz/Y´Èà´4%~œ€¬¹¨‚§è%ƒÛDoQ‹9_Êª6ÄÀÖœ8âpÒ&ıŒ@’ZVé”“ÂzÉ4*”ëIÛ-é¯#éÛK.6ù°¤tY­ÎÕÕU`(cdS•‚è·A|€‡.=ë<'Ö.ºAz,Òú33qı©uÊ¬9<½  ª Q2cŞPğŒéU(]³~C=†+ó#hv|”·4ÄZşşY{ˆ=ÈÅEÉÄbbOØãØµˆ‰%r¾ö»¦X}­ğ¡ğ¤8Á¯½á0&0>Œh†Ç‚¿ÀÑ¾ÿÔ’µ^	åßV?I…éXºŞ”J¦å#²åj9×ŸÜ°ß{€@Ã]·ë).m^óFôÜH¿
ñ'úç¾[ƒl@ƒº„™Ç3ùJ4*ÂÌş˜¶_Pà¼y¡‹R6'w=HÈãO¾-=+òn“Ÿ,H>Ì´øE®™±Ç†qàø^Gc"aØÿWoşöÎv]˜<·Ö?)gî°\8uºËÛYÔwÂC""<R¥Õ	@æù/Ô¤	ÆÍ„ò­Ë7»™öt=~»Îan°î†\}Å½»F=£ë£QÀ´	OLAñcQPÊÉ‘¾OjûØzBıÜR[µ;¶¢[a4Ê‡_<Oÿ©Îõ{^Ş¿mŸu³£_Fô‡>uùwb]ßn£¿×võÛuŞ0Å+«‡/DùØj»¥ |ØÔJô'…ÎI€G•™(½Hçò™J,(HÕ4ú&dNµáÚ”$âª3»4¨mÛ vö´àı©ï“ÇòœH5äTpÅJŒohµ=•àÌ5Rº°YİVÕ×”$ŞŠÖ)!½ìç$Gld°Eİ¤£ÅdJ‚´òiªø ˜	Â¡¸€´HãêY³²ÄxYh@ÌyÆ£hCàé)+U›:êl`.ĞV¨&ZJO.˜š¡èV”>§­{UÄé©,Àj~ø|P^iJÎİ)‰9f‰ıçTDsô<¼{s›/k¥=;§B;í[Çˆ
Ñn½ŸõĞ§ÙD5Eöšˆû²”C‹6pQ &¶ê59QøµéìnåÈf>äU}ùt?ƒÚÓ!2bW§³TÁ@mÆ£w1:>9sœ„&l¡7½1,¤jqƒçÉŞñ—³¾®œÃ¨uœ!ıËêûã
ÈGjÏ ]È;*€ :¬L^áã'Ò!¿æU'òĞb—øyçåËxX„C™ûHh©ô¡»	êºfCÉ½ÑÈ¦#N3§¸˜Õ¹†ÖêÔ+u§ ÄÃ”ØxÄòüc—a¢)0»«t¸ªv	æ¶‹ï×üÙ„İ˜b²÷Vÿw±8•^9/#è7Š ’¢/÷¨h­”*õ±G±!¦ÈfGÎ”	#:É|]|`&•Må˜ä3Sö±9¸»îÒ®BTï‹Rİ«¼Y×ñ-$ğe;Du““]åI²¹sC‹çb=tè°=+ÚÎÁp¡Ïv#¬ÿ] ,Rnå &b“@›37cf¶ç€lQ-¸şê’ïoœÊÃ|­É—ÜšdŞ‹ß%%‚·IĞ••,u¤aI!P©d,26ò¦3Íf½–.8ßçjÊªçZõóÉV8£ê§'DƒMG–Ş@Eã0Âéˆ`íğ
N(hàÂ#‘Ã÷Ş´¨W5ù©rÅˆÕEš¥4ŠŸ=
¯
u¦2e B5Ïˆ†wwÁ¥•J±<“9*ÖÇÂ?
Y%…+bS’Ï‚“—r—S§š—@º¹+yWj±aÓçë()Lô1MáŒƒ”éKóˆÀjT¸¯ùJ)º3õ}xRµàD7@{”Òé÷%QºR„ç§¶„<:<hwoÄüŒğIF2	’ò$†ı`¼s Éõ¡Cv$hş‹˜Ú5d +O‹5$Zh†˜ª¨u§%Í;¥	[¯¾VeòŞ¹İx9¦€¿[2Ö»Ş¶Ò””c.ª%ˆÑ¸ApQd‰º½à˜}0¹İ=yB Lœ<œ¡¤r³¯¦Ü×X¸·Â·²ÒE²ÑS°%4—AAOâÑf.M:VkL?KÆD8„.w-5¿¥zâbE;ä@Ş‹[C²“
³ûıÈïè·ïº8ü¶i‘n±` ‹üì¶ zZC÷]®>÷Ÿ‘ æVxX²{"8YYá—€í•‰z˜É¬6j2][3ÜÔ»İCğşË‘Ëo=öÕbËyÜän—Ü|—Ì‰to‰@Á×n 1¨pººô²*Àl‘çœ¶P°l‡fGuß(„Àû>HW	¥3°:fEwğĞ5,ÏÖÏ¯Rmkn+]-äq—©ME+™E ºÒ9Îï„ÌO—3&-ü¨Óîéî†˜ñL«$t¸º0”'¨ ÌŞ¢	#‘XØiîyÅ/È¯‚\Ùğ3Æ'd@Eú*]0É ³Pı›™<Ë‚È€,!hÖ‰@óJ°Ñ²«˜å ç§$´9RÅ‹Ú*Ş——T¦í_Tù’P2ÎÛ&[3ğo‹„e“id_OŒ»¯B±Ôè¶hC0+­ÕO°iŞö]ÙK±3N©\ì/ÀovÚ÷€ O†aà:¢œW´}¼bdí¸ãğ?Jg°Ó»Ïô75Ÿ¯Ïraì³¸²2#ùSö<„-˜kºÏŞ=~4ó¿uò6\PÄ°†k2H…¸ôC¥Mÿ!æKk0n²¸Í˜¦Á5LÑNC«ôv_`aã×ÅãÄ°“ëËâ×ÔûÏæ]¹áX,€dÃ¡ïg;ş)yx”«,÷NZ\Æˆ›tçæ€°(.
_s¸¤„¹>àé^”ìÌÜ!ÀõìÕçëùx,â¶CÊ¶–wWZ=BÒîñ5XsVÄrî.•zw÷4òµn=<[ü¦kL–~®>+Kz´i×·L)³KL¡»vm>Az$;û0¾ÙÁ Ãˆè•$ÀÚ› €fZİè=™qQ¾­>‘Ìb³‚294«½5ÚÏ L‚)Áe™‘XEØ“§Òë´“{GV
pô‘·kĞa*!rÉ«¼9¢¡u˜w#ªüø|~@ÆT
  VNĞ¡i´t×U(hæ°†°o"Qg¡ÇÏÊµ)AZuJ ²“ğ€¼sÍµnõªHgş%”1\Ï ˜›h—Â„CÔÌ`¨€wC.L`ú©`Èƒ²oWšQ¦Ş‘01xH˜ç"2Ù—K’ÔÖ›ŞtáDjèŠÓ!RdŸi¼šèö™İR5nq‡çŒÂÄ×¬A^d5óNËGÁñ¼X”ÏCH‘ÃÜ…6ıä‹¢ÊÚßAÕ;½“ÈÊõåBO³Œü)Ğàì«%¤ù^áæÆ-MÑQV1‹Ó8ÎÂqJ5 ”hÌ[1." øùnEÂOGX~lkáğN…ï‡¯ğÚ×<aŠOff9AÀ¹:‰‰96ùCäÓÑÍ©Š~9ïãc9‹ …S†{
I_KS¾(µém`„	…¾Ã=í‹o?=ïv.¼€ª{šŠöab"€LÂö ıØ'y=ˆîä3Ï”S/ªªpÆîºên+½ÅsÊîşÏÁæ¿Ûl@×ê]u’ú7s…n‹ÜºçÕŸ÷Ãfÿõÿ8Ùş§pÍ«´¥‰N›üí[{4fÔVËJÍÈ'ËüÄû]ğ “İP(W<*å
æ”p¦ªË“Ë9{Zdy¢t À°ğõ¬Ö ]ğUT6q®)4†*ÒOiÇãuÎl®ğåP‘ÒK¤,z´ªcû4­Ç™HrF?2\*”ZõÌ‰È^©Ğe@E\Èøÿ"æûm¦
¦ÓƒÒömôk´>Õñ„°F¹«<§¢O÷ï ä*Ì˜›^£ñoËoÎã£Şï'GEÅÊEH$™YƒÖ—¨ãúë›Ò5éB€ ×¦‡8oœ¾I'J}'ˆ
MPñnIĞ2¤AÌ–ÁLÂ§C•1³Wu¾¦ÙœqK×¿¬:xKÅÄó®7ï¥^éa,Å0]8k±Pº2ğ#–u¾mG8wth[Òá±ñ:QKÿ,×–î?Èÿa¹ÆsIËóÙØ¬úm‹ï…?[Ş	È¤¤ƒ<ÎñÁƒ¤;KÉsŞ¡<äòa	—†;Ê› H	Ù‚Œ<c	ãRdÌÒj¢}^	CH{9½ş©„ãô8‡©™ÿÉ1¬ëWê•xğz‡R›‘¦İ¹0\|ÄÚ÷ÜaäÖW‚Â[Ö.ôÎ&A‚š”šñyÇö˜öy=rAáÍmxHóf_Æó«¢×H4¯I§*ìıä#Õa×à‹dE‘»
ğ³0õ2×ì\ïD>‚Ü“¯-Ü÷Ù!®»9vá£¸šçºÙÄRÜ2]Ä{‡î¿)`˜ÇSpºÚ×zú›XÖ×Õ˜E1>@«}şU_Ôâ"Nß
µšÔÕèİj>éù½ï!À?AKé’ŒÎŒ/DV% Ë¨Á	·¹¬S¯Y2 #ôÔ"ô¢?ô‰CL;4Ó ì¾2©S€é[›
)s Ò®òİ˜ä¤œ%	”tOq.F•zÔ")a”¬Õ¨¢œ
ß2L¨«¬Æ³‰K^7m„ÑœéÂá…œ•æÇ›sÿÛÊåÅ[J©ò47·¢GnÕ	Õååà­òÔm+ô^»8S`!lLAê¹G D½Ã:kfÂQŞV©Üfîg¤Å1ˆvt»àúU­e.ğ™£²ÂÔVš%>ÔzqRUÿ0<ä3í‚R ª!õÆ®%d#%jeõŠ¦ëôLğÌèo=¼”6‡Ç¶Kº­ä:L- ½BGìVv¿ºÀ½°†È¨÷í®¥Ù¤İè	Ê“Ugx¡	ŒÜ•> êÃ¦& »âË"@m·QøOm£ÃÄ­#ÉÅÓË†—Ö‡-¾~	l¡’’©,76qädë¡*%Í“2 Z\ó32ç ]‰ÈÊïojt¶;UŞ[P}èúUêB‰B)%¨PäRÉ€ˆ]b¹%š7H¤b@ ìStM´\«æ´×ræíb˜]}»‰şıye’ğÖı¿ºôµø¦¨Ì§B‹¿îK%ÃØ%Z@ßá‡1´ì?¸clùÁúît¶v‚ì!ö®11!ƒº!D‚ŒÔíZ×ğî\hõ]åvÀpïñWûQ;v—L^.Òª‰{£ÈfŞ•ÿgí*"$/fí\úø»1ˆAø.·ŒRöİ^¯éÅ	¾¦‘íéÎ+–kMårÛï
afR2ÒÛ¬h/TéË	y:ƒÂÊ`-¼´²x*ú0Lå»ºÌkWó`Xè‘“¯o¢‚ZÜËW˜œeŞÊÜ§ ¢øµÈ²¤OOeŸÕeƒMá#ÿ?Â  ¶·'ƒ‡ö[}hà-}d1àã2Dn;7†ªQİé†êø„~ÈUÑ˜T¤7°ŠŠËL]ğQÂA„Rç0$1³8Áãî²Í«\¶uñ>±³„IˆrñÒ’DÉ¯® Òz®¼eD(-#Dn(šìÎÖe1œŒá<È´•÷Z¦b6Î RĞ3¶­:Øª±ß+š­«ct»¢vœy˜ uøüğ¤ºÔ£­(k.V¤5$bÍº?*}~Ä»ò¾Hcû7øœT%æİL21°LTS$Æ“~pDCĞNÀ/äO·´ª2
Ì{r`vI08Íà˜*:¿…›pVá¬ª'^ô×Ô·g«Dx£C|¼÷,_”M¥Â;1±fû¤ Ùø^r6²a20dÜÈàúNª°XÙ”ÌîçU-›•@k¡Mbœ¨áOË3š”¨üIF1÷æ4¥Â^]º²£6ŒË‹Àú®hEÌbúìúwŒÄ¾¢ƒï¦€NÑ|ı&™éİßÛÚm‘xûÌ–”°ÿ¿ôûç³íß–Š^™5ÌuOßc}DÅÖ0_V³˜»Y¦"r	 tõŠÁÌ>ÛFÕ¤ ÙmŞÏQ/n—ìPJlß ßjèü¸'/–UzĞ¬Ù.X<—ğ]6>]âq>ãS½ñ„_c·u´[Å¹¶+mİ[-ë8Ÿ¶Fa•Û